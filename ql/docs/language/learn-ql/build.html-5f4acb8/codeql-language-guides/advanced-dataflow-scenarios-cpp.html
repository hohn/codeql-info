<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Advanced dataflow scenarios for C/C++ &#8212; CodeQL</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=93459777" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="CodeQL for C#" href="codeql-for-csharp.html" />
    <link rel="prev" title="Hash consing and value numbering" href="hash-consing-and-value-numbering.html" />

<title>CodeQL docs</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="../_static/custom.css" type="text/css" />
<link rel="stylesheet" href="../_static/primer.css" type="text/css" />


  </head><body>
<header class="Header">
    <div class="Header-item--full">
        <a href="https://codeql.github.com/docs" class="Header-link f2 d-flex flex-items-center">
            <!-- <%= octicon "mark-github", class: "mr-2", height: 32 %> -->
            <svg height="32" class="octicon octicon-mark-github mr-2" viewBox="0 0 16 16" version="1.1" width="32"
                aria-hidden="true">
                <path fill-rule="evenodd"
                    d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z">
                </path>
            </svg>
            <span class="hide-sm">CodeQL documentation</span>
        </a>
    </div>
    <div class="Header-item hide-sm hide-md">
        <script src="https://addsearch.com/js/?key=93b4d287e2fc079a4089412b669785d5&categories=!0xhelp.semmle.com,0xcodeql.github.com,1xdocs,1xcodeql-standard-libraries,1xcodeql-query-help"></script>
    </div>
    <div class="Header-item">

        <details class="dropdown details-reset details-overlay d-inline-block">
            <summary class="btn bg-gray-dark text-white border" aria-haspopup="true">
                CodeQL resources
                <div class="dropdown-caret"></div>
            </summary>

            <ul class="dropdown-menu dropdown-menu-se dropdown-menu-dark">
                <li><a class="dropdown-item" href="https://codeql.github.com/docs/codeql-overview">CodeQL overview</a></li>
                <li class="dropdown-divider" role="separator"></li>
                <div class="dropdown-header">
                    CodeQL tools
                </div>
                <li><a class="dropdown-item" href="https://codeql.github.com/docs/codeql-for-visual-studio-code">CodeQL for VS Code</a>
                <li><a class="dropdown-item" href="https://codeql.github.com/docs/codeql-cli">CodeQL CLI</a>
                </li>
                <li class="dropdown-divider" role="separator"></li>
                <div class="dropdown-header">
                    CodeQL guides
                </div>
                <li><a class="dropdown-item" href="https://codeql.github.com/docs/writing-codeql-queries">Writing CodeQL queries</a></li>
                <li><a class="dropdown-item" href="https://codeql.github.com/docs/codeql-language-guides">CodeQL language guides</a>
                <li class="dropdown-divider" role="separator"></li>
                <div class="dropdown-header">
                    Reference docs
                </div>
                <li><a class="dropdown-item" href="https://codeql.github.com/docs/ql-language-reference/">QL language
                        reference</a>
                <li><a class="dropdown-item" href="https://codeql.github.com/codeql-standard-libraries">CodeQL
                        standard-libraries</a>
                <li><a class="dropdown-item" href="https://codeql.github.com/codeql-query-help">CodeQL
                        query help</a>
                <li class="dropdown-divider" role="separator"></li>
                <div class="dropdown-header">
                    Source files
                </div>
                <li><a class="dropdown-item" href="https://github.com/github/codeql">CodeQL repository</a>
            </ul>
        </details>

    </div>

</header>
<main class="bg-gray-light clearfix">
<nav class="SideNav position-sticky top-0 col-lg-3 col-md-3 float-left p-4 hide-sm hide-md overflow-y-auto">

    <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../codeql-overview/index.html">CodeQL overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../codeql-for-visual-studio-code/index.html">CodeQL for Visual Studio Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../codeql-cli/index.html">CodeQL CLI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../writing-codeql-queries/index.html">Writing CodeQL queries</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">CodeQL language guides</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="codeql-for-cpp.html">CodeQL for C and C++</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="basic-query-for-cpp-code.html">Basic query for C and C++ code</a></li>
<li class="toctree-l3"><a class="reference internal" href="codeql-library-for-cpp.html">CodeQL library for C and C++</a></li>
<li class="toctree-l3"><a class="reference internal" href="functions-in-cpp.html">Functions in C and C++</a></li>
<li class="toctree-l3"><a class="reference internal" href="expressions-types-and-statements-in-cpp.html">Expressions, types, and statements in C and C++</a></li>
<li class="toctree-l3"><a class="reference internal" href="conversions-and-classes-in-cpp.html">Conversions and classes in C and C++</a></li>
<li class="toctree-l3"><a class="reference internal" href="analyzing-data-flow-in-cpp.html">Analyzing data flow in C and C++</a></li>
<li class="toctree-l3"><a class="reference internal" href="analyzing-data-flow-in-cpp-new.html">Analyzing data flow in C and C++ (new)</a></li>
<li class="toctree-l3"><a class="reference internal" href="refining-a-query-to-account-for-edge-cases.html">Refining a query to account for edge cases</a></li>
<li class="toctree-l3"><a class="reference internal" href="detecting-a-potential-buffer-overflow.html">Detecting a potential buffer overflow</a></li>
<li class="toctree-l3"><a class="reference internal" href="using-the-guards-library-in-cpp.html">Using the guards library in C and C++</a></li>
<li class="toctree-l3"><a class="reference internal" href="using-range-analsis-in-cpp.html">Using range analysis for C and C++</a></li>
<li class="toctree-l3"><a class="reference internal" href="hash-consing-and-value-numbering.html">Hash consing and value numbering</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Advanced dataflow scenarios for C/C++</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="codeql-for-csharp.html">CodeQL for C#</a></li>
<li class="toctree-l2"><a class="reference internal" href="codeql-for-go.html">CodeQL for Go</a></li>
<li class="toctree-l2"><a class="reference internal" href="codeql-for-java.html">CodeQL for Java and Kotlin</a></li>
<li class="toctree-l2"><a class="reference internal" href="codeql-for-javascript.html">CodeQL for JavaScript and TypeScript</a></li>
<li class="toctree-l2"><a class="reference internal" href="codeql-for-python.html">CodeQL for Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="codeql-for-ruby.html">CodeQL for Ruby</a></li>
<li class="toctree-l2"><a class="reference internal" href="codeql-for-swift.html">CodeQL for Swift</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../ql-language-reference/index.html">QL language reference</a></li>
</ul>


</nav>


<div class="body col-sm-12 col-md-9 col-lg-9 float-left border-left">

    <div class="hide-lg hide-xl px-4 pt-4">
        
<div class="related" role="navigation" aria-label="related navigation">
    <ul>
        <li class="nav-item nav-item-0"><a href="../contents.html">CodeQL</a> &#187;</li>
        <li class="nav-item nav-item-1"><a href="index.html"
                >CodeQL language guides</a> &#187;</li>
        <li class="nav-item nav-item-2"><a href="codeql-for-cpp.html"
                accesskey="U">CodeQL for C and C++</a> &#187;</li> 
    </ul>
</div>
    </div>

    <article class="p-4 col-lg-10 col-md-10 col-sm-12">
        
  <blockquote class="pull-quote" id="advanced-dataflow-scenarios-cpp">
<div><p>Note</p>
<p>The data flow library described here is available from CodeQL 2.12.5 onwards. With the release of CodeQL 2.13.0 the library uses the new modular API for data flow. For information on the previous version of the library, see <a class="reference internal" href="analyzing-data-flow-in-cpp.html#analyzing-data-flow-in-cpp"><span class="std std-ref">Analyzing data flow in C and C++</span></a> and for information about the new modular API and how to migrate any existing queries to the updated data flow library, see <a class="reference external" href="https://gh.io/codeql-new-dataflow-api">New dataflow API for CodeQL query writing</a>.</p>
</div></blockquote>
<section id="advanced-dataflow-scenarios-for-c-c">
<h1>Advanced dataflow scenarios for C/C++<a class="headerlink" href="#advanced-dataflow-scenarios-for-c-c" title="Link to this heading">¶</a></h1>
<p>Data flow for C and C++ distinguishes between the value of a pointer and the value of what the pointer points to. We call this the “indirection” of the pointer. Tracking the pointer and its indirection as separate entities is important for precise dataflow. However, it also means that you need to specify which data flow node to model. If you select the wrong data flow node, then analysis will be flawed. This article discusses several scenarios where it is important to consider whether data flow should be computed on the value of the pointer or its indirection.</p>
<section id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Link to this heading">¶</a></h2>
<p>For almost all situations we only need to instantiate a dataflow configuration and specify our sources and sinks, and the dataflow library will handle everything for us.</p>
<p>However, when a write to a field is not visible to CodeQL (for example, because it happens in a function whose definition is not in the database) we need to track the qualifier, and tell the dataflow library that it should transfer flow from the qualifier to the field access. This is done by adding an <code class="docutils literal notranslate"><span class="pre">isAdditionalFlowStep</span></code> predicate to the dataflow module.</p>
<p>When you write additional flow steps to track pointers, you must decide whether the dataflow step should flow from the pointer or its indirection. Similarly, you must decide whether the additional step should target a pointer or its indirection.</p>
<p>In contrast, if the read of a field is not visible to CodeQL, you can add an <code class="docutils literal notranslate"><span class="pre">allowImplicitRead</span></code> predicate to model the data flow.</p>
</section>
<section id="regular-dataflow-analysis">
<h2>Regular dataflow analysis<a class="headerlink" href="#regular-dataflow-analysis" title="Link to this heading">¶</a></h2>
<p>Consider the following scenario: We have data coming out of <code class="docutils literal notranslate"><span class="pre">user_input()</span></code> and we want to figure out if that data can ever reach an argument of <code class="docutils literal notranslate"><span class="pre">sink</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">sink</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">user_input</span><span class="p">();</span>
</pre></div>
</div>
<p>A regular dataflow query such as the following query:</p>
<div class="highlight-ql notranslate"><div class="highlight"><pre><span></span>/**
* @kind path-problem
*/

import semmle.code.cpp.dataflow.new.DataFlow
import Flow::PathGraph

module Config implements DataFlow::ConfigSig {
  predicate isSource(DataFlow::Node source) {
    source.asExpr().(Call).getTarget().hasName(&quot;user_input&quot;)
  }

  predicate isSink(DataFlow::Node sink) {
    exists(Call call |
      call.getTarget().hasName(&quot;sink&quot;) and
      sink.asExpr() = call.getAnArgument()
    )
  }
}

module Flow = DataFlow::Global&lt;Config&gt;;

from Flow::PathNode source, Flow::PathNode sink
where Flow::flowPath(source, sink)
select sink.getNode(), source, sink, &quot;Flow from user input to sink!&quot;
</pre></div>
</div>
<p>will catch most things such as:</p>
<div class="literal-block-wrapper docutils container" id="id3">
<div class="code-block-caption"><span class="caption-text">Example 1</span><a class="headerlink" href="#id3" title="Link to this code">¶</a></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="k">struct</span><span class="w"> </span><span class="nc">A</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 2</span><span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="linenos"> 3</span><span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="linenos"> 4</span><span class="p">};</span>
<span class="linenos"> 5</span>
<span class="linenos"> 6</span><span class="k">struct</span><span class="w"> </span><span class="nc">B</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 7</span><span class="w">  </span><span class="n">A</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="p">;</span>
<span class="linenos"> 8</span><span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="linenos"> 9</span><span class="p">};</span>
<span class="linenos">10</span>
<span class="linenos">11</span><span class="kt">void</span><span class="w"> </span><span class="nf">fill_structure</span><span class="p">(</span><span class="n">B</span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">pu</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">12</span><span class="w">  </span><span class="c1">// ...</span>
<span class="linenos">13</span><span class="w">  </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pu</span><span class="p">;</span>
<span class="linenos">14</span><span class="p">}</span>
<span class="linenos">15</span>
<span class="linenos">16</span><span class="kt">void</span><span class="w"> </span><span class="nf">process_structure</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">B</span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">17</span><span class="w">  </span><span class="n">sink</span><span class="p">(</span><span class="o">*</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">);</span>
<span class="linenos">18</span><span class="p">}</span>
<span class="linenos">19</span>
<span class="linenos">20</span><span class="kt">void</span><span class="w"> </span><span class="nf">get_and_process</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">21</span><span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">user_input</span><span class="p">();</span>
<span class="linenos">22</span><span class="w">  </span><span class="n">B</span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">B</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">B</span><span class="p">));</span>
<span class="linenos">23</span><span class="w">  </span><span class="c1">// ...</span>
<span class="linenos">24</span><span class="w">  </span><span class="n">fill_structure</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">u</span><span class="p">);</span>
<span class="linenos">25</span><span class="w">  </span><span class="c1">// ...</span>
<span class="linenos">26</span><span class="w">  </span><span class="n">process_structure</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
<span class="linenos">27</span><span class="w">  </span><span class="n">free</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
<span class="linenos">28</span><span class="p">}</span>
</pre></div>
</div>
</div>
<dl class="simple">
<dt>This data flow is simple to match because the CodeQL database contains the information to see:</dt><dd><ol class="arabic simple">
<li><p>User input starts at <code class="docutils literal notranslate"><span class="pre">user_input()</span></code> and flows into <code class="docutils literal notranslate"><span class="pre">fill_structure</span></code>.</p></li>
<li><p>The data is written to the object <code class="docutils literal notranslate"><span class="pre">b</span></code> with access path <code class="docutils literal notranslate"><span class="pre">[a,</span> <span class="pre">p]</span></code>.</p></li>
<li><p>The object <code class="docutils literal notranslate"><span class="pre">b</span></code> flows out of <code class="docutils literal notranslate"><span class="pre">fill_structure</span></code> and into <code class="docutils literal notranslate"><span class="pre">process_structure</span></code>.</p></li>
<li><p>The access path <code class="docutils literal notranslate"><span class="pre">[a,</span> <span class="pre">p]</span></code> is read in <code class="docutils literal notranslate"><span class="pre">process_structure</span></code> and the value ends up in the sink.</p></li>
</ol>
</dd>
</dl>
</section>
<section id="flow-from-a-qualifier-to-a-field-access">
<h2>Flow from a qualifier to a field access<a class="headerlink" href="#flow-from-a-qualifier-to-a-field-access" title="Link to this heading">¶</a></h2>
<p>Sometimes field accesses are not visible to CodeQL (for example, because the implementation of the function isn’t included in the database), and so dataflow cannot match up all stores with reads. This leads to missing (false negative) results.</p>
<p>For example, consider an alternative setup where our source of data starts as the outgoing argument of a function <code class="docutils literal notranslate"><span class="pre">write_user_input_to</span></code>. We can model this setup in the dataflow library using the following <code class="docutils literal notranslate"><span class="pre">isSource</span></code>:</p>
<div class="highlight-ql notranslate"><div class="highlight"><pre><span></span>predicate isSource(DataFlow::Node source) {
  exists(Call call |
    call.getTarget().hasName(&quot;write_user_input_to&quot;) and
    source.asDefiningArgument() = call.getArgument(0)
  )
}
</pre></div>
</div>
<p>This would match the call to <code class="docutils literal notranslate"><span class="pre">write_user_input_to</span></code> in the following example:</p>
<div class="literal-block-wrapper docutils container" id="id4">
<div class="code-block-caption"><span class="caption-text">Example 2</span><a class="headerlink" href="#id4" title="Link to this code">¶</a></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="kt">void</span><span class="w"> </span><span class="nf">write_user_input_to</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
<span class="linenos"> 2</span><span class="kt">void</span><span class="w"> </span><span class="nf">use_value</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="linenos"> 3</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="nf">malloc</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">);</span>
<span class="linenos"> 4</span>
<span class="linenos"> 5</span><span class="k">struct</span><span class="w"> </span><span class="nc">U</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 6</span><span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
<span class="linenos"> 7</span><span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="linenos"> 8</span><span class="p">};</span>
<span class="linenos"> 9</span>
<span class="linenos">10</span><span class="kt">void</span><span class="w"> </span><span class="nf">process_user_data</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">11</span><span class="w">  </span><span class="c1">// ...</span>
<span class="linenos">12</span><span class="w">  </span><span class="n">use_value</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">);</span>
<span class="linenos">13</span><span class="p">}</span>
<span class="linenos">14</span>
<span class="linenos">15</span><span class="kt">void</span><span class="w"> </span><span class="nf">get_and_process_user_input_v2</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">16</span><span class="w">  </span><span class="n">U</span><span class="o">*</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">U</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">U</span><span class="p">));</span>
<span class="linenos">17</span><span class="w">  </span><span class="n">write_user_input_to</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
<span class="linenos">18</span><span class="w">  </span><span class="n">process_user_data</span><span class="p">(</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">);</span>
<span class="linenos">19</span><span class="w">  </span><span class="n">free</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
<span class="linenos">20</span><span class="p">}</span>
</pre></div>
</div>
</div>
<p>With this definition of <code class="docutils literal notranslate"><span class="pre">isSource</span></code> the dataflow library tracks flow along the following path:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>The flow now starts at the outgoing argument of <code class="docutils literal notranslate"><span class="pre">write_user_input_to(...)</span></code>.</p></li>
<li><p>The flow proceeds to <code class="docutils literal notranslate"><span class="pre">u-&gt;p</span></code> on the next line.</p></li>
</ol>
</div></blockquote>
<p>However, because CodeQL has not observed a write to <code class="docutils literal notranslate"><span class="pre">p</span></code> before the read <code class="docutils literal notranslate"><span class="pre">u-&gt;p</span></code>, dataflow will stop at <code class="docutils literal notranslate"><span class="pre">u</span></code>. We can correct this gap in the information available to dataflow by adding an additional flow step through field reads:</p>
<div class="highlight-ql notranslate"><div class="highlight"><pre><span></span>/**
* @kind path-problem
*/

import semmle.code.cpp.dataflow.new.DataFlow
import Flow::PathGraph

module Config implements DataFlow::ConfigSig {
  predicate isSource(DataFlow::Node source) {
    exists(Call call |
      call.getTarget().hasName(&quot;write_user_input_to&quot;) and
      source.asDefiningArgument() = call.getArgument(0)
    )
  }

  predicate isSink(DataFlow::Node sink) {
    exists(Call call |
      call.getTarget().hasName(&quot;use_value&quot;) and
      sink.asExpr() = call.getAnArgument()
    )
  }

  predicate isAdditionalFlowStep(DataFlow::Node n1, DataFlow::Node n2) {
    exists(FieldAccess fa |
      n1.asIndirectExpr() = fa.getQualifier() and
      n2.asIndirectExpr() = fa
    )
  }
}

module Flow = DataFlow::Global&lt;Config&gt;;

from Flow::PathNode source, Flow::PathNode sink
where Flow::flowPath(source, sink)
select sink.getNode(), source, sink, &quot;Flow from user input to sink!&quot;
</pre></div>
</div>
<p>Notice how the <code class="docutils literal notranslate"><span class="pre">isSource</span></code> and <code class="docutils literal notranslate"><span class="pre">isSink</span></code> are as expected: we’re looking for flow that starts at the outgoing parameter of <code class="docutils literal notranslate"><span class="pre">write_user_input_to(...)</span></code>, and ends up as an argument to <code class="docutils literal notranslate"><span class="pre">isSink</span></code>. The interesting part is the addition of <code class="docutils literal notranslate"><span class="pre">isAdditionalFlow</span></code> which specifies an additional flow step from the qualifier of a <code class="docutils literal notranslate"><span class="pre">FieldAccess</span></code> to the result of the access.</p>
<p>In a real query the <code class="docutils literal notranslate"><span class="pre">isAdditionalFlowStep</span></code> step would be restricted in various ways to make sure that it doesn’t add too much flow (since flow from a field qualifier to the field access in general will generate a lot of spurious flow). For example, one could restrict <code class="docutils literal notranslate"><span class="pre">fa</span></code> to be a field access that targets a particular field, or a field access of a field that’s defined in a certain <code class="docutils literal notranslate"><span class="pre">struct</span></code> type.</p>
<p>We have an important choice here: Should <code class="docutils literal notranslate"><span class="pre">n2</span></code> be the node corresponding to the pointer value of <code class="docutils literal notranslate"><span class="pre">fa</span></code> or the indirection of <code class="docutils literal notranslate"><span class="pre">fa</span></code> (that is, what <code class="docutils literal notranslate"><span class="pre">fa</span></code> points to)?</p>
<section id="using-asindirectexpr">
<span id="id1"></span><h3>Using asIndirectExpr<a class="headerlink" href="#using-asindirectexpr" title="Link to this heading">¶</a></h3>
<p>If we use <code class="docutils literal notranslate"><span class="pre">n2.asIndirectExpr()</span> <span class="pre">=</span> <span class="pre">fa</span></code> we specify that flow in example 2 moves to what <code class="docutils literal notranslate"><span class="pre">fa</span></code> points to. This allows data to flow through a later dereference, which is exactly what we need to track data flow from <code class="docutils literal notranslate"><span class="pre">p</span></code> to <code class="docutils literal notranslate"><span class="pre">*p</span></code> in <code class="docutils literal notranslate"><span class="pre">process_user_data</span></code>.</p>
<p>Thus we get the required flow path.</p>
<p>Consider a slightly different sink:</p>
<div class="literal-block-wrapper docutils container" id="id5">
<div class="code-block-caption"><span class="caption-text">Example 3</span><a class="headerlink" href="#id5" title="Link to this code">¶</a></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="kt">void</span><span class="w"> </span><span class="nf">write_user_input_to</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
<span class="linenos"> 2</span><span class="kt">void</span><span class="w"> </span><span class="nf">use_pointer</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">);</span>
<span class="linenos"> 3</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="nf">malloc</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">);</span>
<span class="linenos"> 4</span>
<span class="linenos"> 5</span><span class="k">struct</span><span class="w"> </span><span class="nc">U</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 6</span><span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
<span class="linenos"> 7</span><span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="linenos"> 8</span><span class="p">};</span>
<span class="linenos"> 9</span>
<span class="linenos">10</span><span class="kt">void</span><span class="w"> </span><span class="nf">process_user_data</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">11</span><span class="w">  </span><span class="c1">// ...</span>
<span class="linenos">12</span><span class="w">  </span><span class="n">use_pointer</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="linenos">13</span><span class="p">}</span>
<span class="linenos">14</span>
<span class="linenos">15</span><span class="kt">void</span><span class="w"> </span><span class="nf">get_and_process_user_input_v2</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">16</span><span class="w">  </span><span class="n">U</span><span class="o">*</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">U</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">U</span><span class="p">));</span>
<span class="linenos">17</span><span class="w">  </span><span class="n">write_user_input_to</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
<span class="linenos">18</span><span class="w">  </span><span class="n">process_user_data</span><span class="p">(</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">);</span>
<span class="linenos">19</span><span class="w">  </span><span class="n">free</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
<span class="linenos">20</span><span class="p">}</span>
</pre></div>
</div>
</div>
<p>The only difference between the previous example and this one is that our data ends up in a call to <code class="docutils literal notranslate"><span class="pre">use_pointer</span></code> which takes an <code class="docutils literal notranslate"><span class="pre">int*</span></code> instead of an <code class="docutils literal notranslate"><span class="pre">int</span></code> as an argument. Since our <code class="docutils literal notranslate"><span class="pre">isAdditionalFlowStep</span></code> implementation already steps to the indirection of the <code class="docutils literal notranslate"><span class="pre">FieldAccess</span></code> we’re already tracking what the field points to. So we can find this flow by using <code class="docutils literal notranslate"><span class="pre">sink.asIndirectExpr()</span></code> to specify that the data we’re interested in tracking is the value that ends up being pointed to by an argument that is passed to <code class="docutils literal notranslate"><span class="pre">use_pointer</span></code>:</p>
<div class="highlight-ql notranslate"><div class="highlight"><pre><span></span>predicate isSink(DataFlow::Node sink) {
  exists(Call call |
    call.getTarget().hasName(&quot;use_pointer&quot;) and
    sink.asIndirectExpr() = call.getAnArgument()
  )
}
</pre></div>
</div>
</section>
<section id="using-asexpr">
<span id="id2"></span><h3>Using asExpr<a class="headerlink" href="#using-asexpr" title="Link to this heading">¶</a></h3>
<dl class="simple">
<dt>Alternatively, the flow in example 2 could also be tracked by:</dt><dd><ol class="arabic simple">
<li><p>Changing <code class="docutils literal notranslate"><span class="pre">isAdditionalFlowStep</span></code> so that it targets the dataflow node that represents the value of the <code class="docutils literal notranslate"><span class="pre">FieldAccess</span></code> instead of the value it points to, and</p></li>
<li><p>Changing <code class="docutils literal notranslate"><span class="pre">isSink</span></code> to specify that we’re interested in tracking the value the argument passed to <code class="docutils literal notranslate"><span class="pre">use_pointer</span></code> (instead of the value of what the argument points to).</p></li>
</ol>
</dd>
</dl>
<p>With those changes our query becomes:</p>
<div class="highlight-ql notranslate"><div class="highlight"><pre><span></span>/**
* @kind path-problem
*/

import semmle.code.cpp.dataflow.new.DataFlow
import Flow::PathGraph

module Config implements DataFlow::ConfigSig {
  predicate isSource(DataFlow::Node source) {
    exists(Call call |
      call.getTarget().hasName(&quot;write_user_input_to&quot;) and
      source.asDefiningArgument() = call.getArgument(0)
    )
  }

  predicate isSink(DataFlow::Node sink) {
    exists(Call call |
      call.getTarget().hasName(&quot;use_pointer&quot;) and
      sink.asExpr() = call.getAnArgument()
    )
  }

  predicate isAdditionalFlowStep(DataFlow::Node n1, DataFlow::Node n2) {
    exists(FieldAccess fa |
      n1.asIndirectExpr() = fa.getQualifier() and
      n2.asExpr() = fa
    )
  }
}

module Flow = DataFlow::Global&lt;Config&gt;;

from Flow::PathNode source, Flow::PathNode sink
where Flow::flowPath(source, sink)
select sink.getNode(), source, sink, &quot;Flow from user input to sink!&quot;
</pre></div>
</div>
<p>When we get to <code class="docutils literal notranslate"><span class="pre">u-&gt;p</span></code> the additional step transfers flow from what the qualifier points to, to the result of the <code class="docutils literal notranslate"><span class="pre">FieldAccess</span></code>. After this, dataflow proceeds to <code class="docutils literal notranslate"><span class="pre">p</span></code> in <code class="docutils literal notranslate"><span class="pre">use_pointer(p)</span></code> and since we specified in our <code class="docutils literal notranslate"><span class="pre">isSink</span></code> that we’re interested in the value of the argument, our dataflow analysis finds a result.</p>
</section>
<section id="passing-the-address-of-a-variable-to-use-pointer">
<h3>Passing the address of a variable to <code class="docutils literal notranslate"><span class="pre">use_pointer</span></code><a class="headerlink" href="#passing-the-address-of-a-variable-to-use-pointer" title="Link to this heading">¶</a></h3>
<p>Consider an alternative scenario where <code class="docutils literal notranslate"><span class="pre">U</span></code> contains a single <code class="docutils literal notranslate"><span class="pre">int</span></code> data, and we pass the address of data to <code class="docutils literal notranslate"><span class="pre">use_pointer</span></code> as seen below.</p>
<div class="literal-block-wrapper docutils container" id="id6">
<div class="code-block-caption"><span class="caption-text">Example 4</span><a class="headerlink" href="#id6" title="Link to this code">¶</a></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="kt">void</span><span class="w"> </span><span class="nf">write_user_input_to</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
<span class="linenos"> 2</span><span class="kt">void</span><span class="w"> </span><span class="nf">use_pointer</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">);</span>
<span class="linenos"> 3</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="nf">malloc</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">);</span>
<span class="linenos"> 4</span>
<span class="linenos"> 5</span><span class="k">struct</span><span class="w"> </span><span class="nc">U</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 6</span><span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">data</span><span class="p">;</span>
<span class="linenos"> 7</span><span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="linenos"> 8</span><span class="p">};</span>
<span class="linenos"> 9</span>
<span class="linenos">10</span><span class="kt">void</span><span class="w"> </span><span class="nf">process_user_data</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">11</span><span class="w">  </span><span class="c1">// ...</span>
<span class="linenos">12</span><span class="w">  </span><span class="n">use_pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
<span class="linenos">13</span><span class="p">}</span>
<span class="linenos">14</span>
<span class="linenos">15</span>
<span class="linenos">16</span><span class="kt">void</span><span class="w"> </span><span class="nf">get_and_process_user_input_v2</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">17</span><span class="w">  </span><span class="n">U</span><span class="o">*</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">U</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">U</span><span class="p">));</span>
<span class="linenos">18</span><span class="w">  </span><span class="n">write_user_input_to</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
<span class="linenos">19</span><span class="w">  </span><span class="n">process_user_data</span><span class="p">(</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
<span class="linenos">20</span><span class="w">  </span><span class="n">free</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
<span class="linenos">21</span><span class="p">}</span>
</pre></div>
</div>
</div>
<p>Since the <code class="docutils literal notranslate"><span class="pre">data</span></code> field is now an <code class="docutils literal notranslate"><span class="pre">int</span></code> instead of an <code class="docutils literal notranslate"><span class="pre">int*</span></code> the field no longer has any indirections, and so the use of <code class="docutils literal notranslate"><span class="pre">asIndirectExpr</span></code> in <code class="docutils literal notranslate"><span class="pre">isAdditionalFlowStep</span></code> no longer makes sense (and so the additional step will have no results). So there is no choice about whether to taint the value of the field or its indirection: it has to be the value.</p>
<dl class="simple">
<dt>However, since we pass the address of <code class="docutils literal notranslate"><span class="pre">data</span></code> to <code class="docutils literal notranslate"><span class="pre">use_pointer</span></code> on line 12 the tainted value is what is pointed to by the argument of <code class="docutils literal notranslate"><span class="pre">use_pointer</span></code> (since the value pointed to by <code class="docutils literal notranslate"><span class="pre">&amp;data</span></code> is exactly <code class="docutils literal notranslate"><span class="pre">data</span></code>). So to handle this case we need a mix of the two situations above:</dt><dd><ol class="arabic simple">
<li><p>We need to taint the value of the field as described in the <a class="reference internal" href="#using-asexpr"><span class="std std-ref">Using asExpr</span></a> section.</p></li>
<li><p>We need to select the indirection of the argument as described in the <a class="reference internal" href="#using-asindirectexpr"><span class="std std-ref">Using asIndirectExpr</span></a> section.</p></li>
</ol>
</dd>
</dl>
<p>With these changes the query looks like:</p>
<div class="highlight-ql notranslate"><div class="highlight"><pre><span></span>/**
* @kind path-problem
*/

import semmle.code.cpp.dataflow.new.DataFlow
import Flow::PathGraph

module Config implements DataFlow::ConfigSig {
  predicate isSource(DataFlow::Node source) {
    exists(Call call |
      call.getTarget().hasName(&quot;write_user_input_to&quot;) and
      source.asDefiningArgument() = call.getArgument(0)
    )
  }

  predicate isSink(DataFlow::Node sink) {
    exists(Call call |
      call.getTarget().hasName(&quot;use_pointer&quot;) and
      sink.asIndirectExpr() = call.getAnArgument()
    )
  }

  predicate isAdditionalFlowStep(DataFlow::Node n1, DataFlow::Node n2) {
    exists(FieldAccess fa |
      n1.asIndirectExpr() = fa.getQualifier() and
      n2.asExpr() = fa
    )
  }
}

module Flow = DataFlow::Global&lt;Config&gt;;

from Flow::PathNode source, Flow::PathNode sink
where Flow::flowPath(source, sink)
select sink.getNode(), source, sink, &quot;Flow from user input to sink!&quot;
</pre></div>
</div>
<p>And with that query the flow is identified.</p>
</section>
</section>
<section id="specifying-implicit-reads">
<h2>Specifying implicit reads<a class="headerlink" href="#specifying-implicit-reads" title="Link to this heading">¶</a></h2>
<p>The previous section demonstrated how to add flow from qualifiers to field accesses because a source implicitly tainted all the fields of a struct. This section considers the opposite scenario: A specific field is being tainted, and we want to find any place that may read from this object, including any place that reads an unknown set of fields.</p>
<p>To set the stage, consider the following scenario:</p>
<div class="literal-block-wrapper docutils container" id="id7">
<div class="code-block-caption"><span class="caption-text">Example 5</span><a class="headerlink" href="#id7" title="Link to this code">¶</a></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="k">struct</span><span class="w"> </span><span class="nc">A</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 2</span><span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="linenos"> 3</span><span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="linenos"> 4</span><span class="p">};</span>
<span class="linenos"> 5</span>
<span class="linenos"> 6</span><span class="k">struct</span><span class="w"> </span><span class="nc">B</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 7</span><span class="w">  </span><span class="n">A</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="p">;</span>
<span class="linenos"> 8</span><span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">z</span><span class="p">;</span>
<span class="linenos"> 9</span><span class="p">};</span>
<span class="linenos">10</span>
<span class="linenos">11</span><span class="kt">int</span><span class="w"> </span><span class="nf">user_input</span><span class="p">();</span>
<span class="linenos">12</span><span class="kt">void</span><span class="w"> </span><span class="nf">read_data</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="linenos">13</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">malloc</span><span class="p">(</span><span class="kt">size_t</span><span class="p">);</span>
<span class="linenos">14</span>
<span class="linenos">15</span><span class="kt">void</span><span class="w"> </span><span class="nf">get_input_and_read_data</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">16</span><span class="w">  </span><span class="n">B</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="linenos">17</span><span class="w">  </span><span class="n">b</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">A</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">A</span><span class="p">));</span>
<span class="linenos">18</span><span class="w">  </span><span class="n">b</span><span class="p">.</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">user_input</span><span class="p">();</span>
<span class="linenos">19</span><span class="w">  </span><span class="c1">// ...</span>
<span class="linenos">20</span><span class="w">  </span><span class="n">read_data</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
<span class="linenos">21</span><span class="w">  </span><span class="n">free</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">a</span><span class="p">);</span>
<span class="linenos">22</span><span class="p">}</span>
</pre></div>
</div>
</div>
<p>In this example, the data flows as follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>We write a user-controlled value into the object <code class="docutils literal notranslate"><span class="pre">b</span></code> at the access path <code class="docutils literal notranslate"><span class="pre">[a,</span> <span class="pre">x]</span></code>.</p></li>
<li><p>Afterwards, <code class="docutils literal notranslate"><span class="pre">b</span></code> is passed to <code class="docutils literal notranslate"><span class="pre">read_data</span></code> which we don’t have the definition of in the database.</p></li>
</ol>
</div></blockquote>
<p>We now want to track this user-input flowing into <code class="docutils literal notranslate"><span class="pre">read_data</span></code>.</p>
<p>The dataflow library has a specific predicate to handle this scenario, and thus we don’t need to add any additional flow steps using <code class="docutils literal notranslate"><span class="pre">isAdditionalFlowStep</span></code>. Instead, we tell the dataflow library that <code class="docutils literal notranslate"><span class="pre">read_data</span></code> is a sink and may implicitly read the data from fields in the object it is passed. To do that, we implement <code class="docutils literal notranslate"><span class="pre">allowImplicitRead</span></code> in our dataflow module:</p>
<div class="highlight-ql notranslate"><div class="highlight"><pre><span></span>/**
* @kind path-problem
*/

import semmle.code.cpp.dataflow.new.DataFlow
import Flow::PathGraph

module Config implements DataFlow::ConfigSig {
  predicate isSource(DataFlow::Node source) {
    exists(Call call |
      call.getTarget().hasName(&quot;user_input&quot;) and
      source.asExpr() = call
    )
  }

  predicate isSink(DataFlow::Node sink) {
    exists(Call call |
      call.getTarget().hasName(&quot;read_data&quot;) and
      sink.asIndirectExpr() = call.getAnArgument()
    )
  }

  predicate allowImplicitRead(DataFlow::Node n, DataFlow::ContentSet cs) {
    isSink(n) and
    cs.getAReadContent().(DataFlow::FieldContent).getField().hasName([&quot;a&quot;, &quot;x&quot;])
  }
}

module Flow = DataFlow::Global&lt;Config&gt;;

from Flow::PathNode source, Flow::PathNode sink
where Flow::flowPath(source, sink)
select sink.getNode(), source, sink, &quot;Flow from user input to sink!&quot;
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">allowImplicitRead</span></code> predicate specifies that if we’re at a node that satisfies <code class="docutils literal notranslate"><span class="pre">isSink</span></code> then we’re allowed to assume that there is an implicit read of a field named <code class="docutils literal notranslate"><span class="pre">a</span></code> or a field named <code class="docutils literal notranslate"><span class="pre">x</span></code> (in this case both). This gets us the flow we are interested in because the dataflow library now will see:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>User input starts at <code class="docutils literal notranslate"><span class="pre">user_input()</span></code>.</p></li>
<li><p>The data flowing into <code class="docutils literal notranslate"><span class="pre">b</span></code> with access path <code class="docutils literal notranslate"><span class="pre">[a,</span> <span class="pre">x]</span></code>.</p></li>
<li><p>The data flowing to the indirection of <code class="docutils literal notranslate"><span class="pre">&amp;b</span></code> (i.e., the object <code class="docutils literal notranslate"><span class="pre">b</span></code>).</p></li>
<li><p>An implicit read of the field <code class="docutils literal notranslate"><span class="pre">x</span></code> followed by an implicit read of the field <code class="docutils literal notranslate"><span class="pre">a</span></code> at the sink.</p></li>
</ol>
</div></blockquote>
<p>Thus, we end up at a node that satisfies <code class="docutils literal notranslate"><span class="pre">isSink</span></code> with an empty access path, and successfully track the full dataflow path.</p>
</section>
</section>


    </article>

    <!-- GitHub footer, with links to terms and privacy statement -->
    <div class="px-3 px-md-6 f6 py-4 d-sm-flex flex-justify-between flex-row-reverse flex-items-center border-top">
        <ul class="list-style-none d-flex flex-items-center mb-3 mb-sm-0 lh-condensed-ultra">
            <li class="mr-3">
                <a href="https://twitter.com/github" title="GitHub on Twitter" style="color: #959da5;">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 273.5 222.3" class="d-block" height="18">
                        <path
                            d="M273.5 26.3a109.77 109.77 0 0 1-32.2 8.8 56.07 56.07 0 0 0 24.7-31 113.39 113.39 0 0 1-35.7 13.6 56.1 56.1 0 0 0-97 38.4 54 54 0 0 0 1.5 12.8A159.68 159.68 0 0 1 19.1 10.3a56.12 56.12 0 0 0 17.4 74.9 56.06 56.06 0 0 1-25.4-7v.7a56.11 56.11 0 0 0 45 55 55.65 55.65 0 0 1-14.8 2 62.39 62.39 0 0 1-10.6-1 56.24 56.24 0 0 0 52.4 39 112.87 112.87 0 0 1-69.7 24 119 119 0 0 1-13.4-.8 158.83 158.83 0 0 0 86 25.2c103.2 0 159.6-85.5 159.6-159.6 0-2.4-.1-4.9-.2-7.3a114.25 114.25 0 0 0 28.1-29.1"
                            fill="currentColor"></path>
                    </svg>
                </a>
            </li>
            <li class="mr-3">
                <a href="https://www.facebook.com/GitHub" title="GitHub on Facebook" style="color: #959da5;">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.3 15.4" class="d-block" height="18">
                        <path
                            d="M14.5 0H.8a.88.88 0 0 0-.8.9v13.6a.88.88 0 0 0 .8.9h7.3v-6h-2V7.1h2V5.4a2.87 2.87 0 0 1 2.5-3.1h.5a10.87 10.87 0 0 1 1.8.1v2.1h-1.3c-1 0-1.1.5-1.1 1.1v1.5h2.3l-.3 2.3h-2v5.9h3.9a.88.88 0 0 0 .9-.8V.8a.86.86 0 0 0-.8-.8z"
                            fill="currentColor"></path>
                    </svg>
                </a>
            </li>
            <li class="mr-3">
                <a href="https://www.youtube.com/github" title="GitHub on YouTube" style="color: #959da5;">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.17 13.6" class="d-block" height="16">
                        <path
                            d="M18.77 2.13A2.4 2.4 0 0 0 17.09.42C15.59 0 9.58 0 9.58 0a57.55 57.55 0 0 0-7.5.4A2.49 2.49 0 0 0 .39 2.13 26.27 26.27 0 0 0 0 6.8a26.15 26.15 0 0 0 .39 4.67 2.43 2.43 0 0 0 1.69 1.71c1.52.42 7.5.42 7.5.42a57.69 57.69 0 0 0 7.51-.4 2.4 2.4 0 0 0 1.68-1.71 25.63 25.63 0 0 0 .4-4.67 24 24 0 0 0-.4-4.69zM7.67 9.71V3.89l5 2.91z"
                            fill="currentColor"></path>
                    </svg>
                </a>
            </li>
            <li class="mr-3 flex-self-start">
                <a href="https://www.linkedin.com/company/github" title="GitHub on Linkedin" style="color: #959da5;">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19 18" class="d-block" height="18">
                        <path
                            d="M3.94 2A2 2 0 1 1 2 0a2 2 0 0 1 1.94 2zM4 5.48H0V18h4zm6.32 0H6.34V18h3.94v-6.57c0-3.66 4.77-4 4.77 0V18H19v-7.93c0-6.17-7.06-5.94-8.72-2.91z"
                            fill="currentColor"></path>
                    </svg>
                </a>
            </li>
            <li>
                <a href="https://github.com/github" title="GitHub's organization" style="color: #959da5;">
                    <svg version="1.1" width="20" height="20" viewBox="0 0 16 16" class="octicon octicon-mark-github"
                        aria-hidden="true">
                        <path fill-rule="evenodd"
                            d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z">
                        </path>
                    </svg>
                </a>
            </li>
        </ul>
        <ul class="list-style-none d-flex text-gray">
            <li class="mr-3">&copy; 
                <script type="text/javascript">document.write(new Date().getFullYear());</script> GitHub, Inc.</li>
            <li class="mr-3"><a
                    href="https://docs.github.com/github/site-policy/github-terms-of-service"
                    class="link-gray">Terms </a></li>
            <li><a href="https://docs.github.com/github/site-policy/github-privacy-statement"
                    class="link-gray">Privacy </a></li>
        </ul>
    </div>
</div>
</main>

<script type="text/javascript">
    $(document).ready(function () {
        $(".toggle > *").hide();
        $(".toggle .name").show();
        $(".toggle .name").click(function () {
            $(this).parent().children().not(".name").toggle(400);
            $(this).parent().children(".name").toggleClass("open");
        })
    });
</script>

  </body>
</html>