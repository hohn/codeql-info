<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Expressions &#8212; CodeQL</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=93459777" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Formulas" href="formulas.html" />
    <link rel="prev" title="Variables" href="variables.html" />

<title>CodeQL docs</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="../_static/custom.css" type="text/css" />
<link rel="stylesheet" href="../_static/primer.css" type="text/css" />


  </head><body>
<header class="Header">
    <div class="Header-item--full">
        <a href="https://codeql.github.com/docs" class="Header-link f2 d-flex flex-items-center">
            <!-- <%= octicon "mark-github", class: "mr-2", height: 32 %> -->
            <svg height="32" class="octicon octicon-mark-github mr-2" viewBox="0 0 16 16" version="1.1" width="32"
                aria-hidden="true">
                <path fill-rule="evenodd"
                    d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z">
                </path>
            </svg>
            <span class="hide-sm">CodeQL documentation</span>
        </a>
    </div>
    <div class="Header-item hide-sm hide-md">
        <script src="https://addsearch.com/js/?key=93b4d287e2fc079a4089412b669785d5&categories=!0xhelp.semmle.com,0xcodeql.github.com,1xdocs,1xcodeql-standard-libraries,1xcodeql-query-help"></script>
    </div>
    <div class="Header-item">

        <details class="dropdown details-reset details-overlay d-inline-block">
            <summary class="btn bg-gray-dark text-white border" aria-haspopup="true">
                CodeQL resources
                <div class="dropdown-caret"></div>
            </summary>

            <ul class="dropdown-menu dropdown-menu-se dropdown-menu-dark">
                <li><a class="dropdown-item" href="https://codeql.github.com/docs/codeql-overview">CodeQL overview</a></li>
                <li class="dropdown-divider" role="separator"></li>
                <div class="dropdown-header">
                    CodeQL tools
                </div>
                <li><a class="dropdown-item" href="https://codeql.github.com/docs/codeql-for-visual-studio-code">CodeQL for VS Code</a>
                <li><a class="dropdown-item" href="https://codeql.github.com/docs/codeql-cli">CodeQL CLI</a>
                </li>
                <li class="dropdown-divider" role="separator"></li>
                <div class="dropdown-header">
                    CodeQL guides
                </div>
                <li><a class="dropdown-item" href="https://codeql.github.com/docs/writing-codeql-queries">Writing CodeQL queries</a></li>
                <li><a class="dropdown-item" href="https://codeql.github.com/docs/codeql-language-guides">CodeQL language guides</a>
                <li class="dropdown-divider" role="separator"></li>
                <div class="dropdown-header">
                    Reference docs
                </div>
                <li><a class="dropdown-item" href="https://codeql.github.com/docs/ql-language-reference/">QL language
                        reference</a>
                <li><a class="dropdown-item" href="https://codeql.github.com/codeql-standard-libraries">CodeQL
                        standard-libraries</a>
                <li><a class="dropdown-item" href="https://codeql.github.com/codeql-query-help">CodeQL
                        query help</a>
                <li class="dropdown-divider" role="separator"></li>
                <div class="dropdown-header">
                    Source files
                </div>
                <li><a class="dropdown-item" href="https://github.com/github/codeql">CodeQL repository</a>
            </ul>
        </details>

    </div>

</header>
<main class="bg-gray-light clearfix">
<nav class="SideNav position-sticky top-0 col-lg-3 col-md-3 float-left p-4 hide-sm hide-md overflow-y-auto">

    <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../codeql-overview/index.html">CodeQL overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../codeql-for-visual-studio-code/index.html">CodeQL for Visual Studio Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../codeql-cli/index.html">CodeQL CLI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../writing-codeql-queries/index.html">Writing CodeQL queries</a></li>
<li class="toctree-l1"><a class="reference internal" href="../codeql-language-guides/index.html">CodeQL language guides</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">QL language reference</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="about-the-ql-language.html">About the QL language</a></li>
<li class="toctree-l2"><a class="reference internal" href="predicates.html">Predicates</a></li>
<li class="toctree-l2"><a class="reference internal" href="queries.html">Queries</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="modules.html">Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="aliases.html">Aliases</a></li>
<li class="toctree-l2"><a class="reference internal" href="variables.html">Variables</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="formulas.html">Formulas</a></li>
<li class="toctree-l2"><a class="reference internal" href="annotations.html">Annotations</a></li>
<li class="toctree-l2"><a class="reference internal" href="recursion.html">Recursion</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexical-syntax.html">Lexical syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="name-resolution.html">Name resolution</a></li>
<li class="toctree-l2"><a class="reference internal" href="evaluation-of-ql-programs.html">Evaluation of QL programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="ql-language-specification.html">QL language specification</a></li>
</ul>
</li>
</ul>


</nav>


<div class="body col-sm-12 col-md-9 col-lg-9 float-left border-left">

    <div class="hide-lg hide-xl px-4 pt-4">
        
<div class="related" role="navigation" aria-label="related navigation">
    <ul>
        <li class="nav-item nav-item-0"><a href="../contents.html">CodeQL</a> &#187;</li>
        <li class="nav-item nav-item-1"><a href="index.html"
                accesskey="U">QL language reference</a> &#187;</li> 
    </ul>
</div>
    </div>

    <article class="p-4 col-lg-10 col-md-10 col-sm-12">
        
  <section id="expressions">
<span id="id1"></span><h1>Expressions<a class="headerlink" href="#expressions" title="Link to this heading">¶</a></h1>
<p>An expression evaluates to a set of values and has a type.</p>
<p>For example, the expression <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">+</span> <span class="pre">2</span></code>
evaluates to the integer <code class="docutils literal notranslate"><span class="pre">3</span></code> and the expression <code class="docutils literal notranslate"><span class="pre">&quot;QL&quot;</span></code> evaluates to the string <code class="docutils literal notranslate"><span class="pre">&quot;QL&quot;</span></code>. <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">+</span> <span class="pre">2</span></code> has <a class="reference internal" href="types.html#types"><span class="std std-ref">type</span></a> <code class="docutils literal notranslate"><span class="pre">int</span></code> and <code class="docutils literal notranslate"><span class="pre">&quot;QL&quot;</span></code> has type <code class="docutils literal notranslate"><span class="pre">string</span></code>.</p>
<p>The following sections describe the expressions that are available in QL.</p>
<section id="variable-references">
<h2>Variable references<a class="headerlink" href="#variable-references" title="Link to this heading">¶</a></h2>
<p>A variable reference is the name of a declared <a class="reference internal" href="variables.html#variables"><span class="std std-ref">variable</span></a>. This kind of
expression has the same type as the variable it refers to.</p>
<p>For example, if you have <a class="reference internal" href="variables.html#variable-declarations"><span class="std std-ref">declared</span></a> the variables <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code> and <code class="docutils literal notranslate"><span class="pre">LocalScopeVariable</span> <span class="pre">lsv</span></code>, then
the expressions <code class="docutils literal notranslate"><span class="pre">i</span></code> and <code class="docutils literal notranslate"><span class="pre">lsv</span></code> have types <code class="docutils literal notranslate"><span class="pre">int</span></code> and <code class="docutils literal notranslate"><span class="pre">LocalScopeVariable</span></code> respectively.</p>
<p>You can also refer to the variables <code class="docutils literal notranslate"><span class="pre">this</span></code> and <code class="docutils literal notranslate"><span class="pre">result</span></code>. These are used in <a class="reference internal" href="predicates.html#predicates"><span class="std std-ref">predicate</span></a> definitions and act in the same way as other variable references.</p>
</section>
<section id="literals">
<span id="index-0"></span><h2>Literals<a class="headerlink" href="#literals" title="Link to this heading">¶</a></h2>
<p>You can express certain values directly in QL, such as numbers, booleans, and strings.</p>
<ul>
<li><p><a class="reference internal" href="types.html#boolean"><span class="std std-ref">Boolean</span></a> literals: These are the values <code class="docutils literal notranslate"><span class="pre">true</span></code> and <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p></li>
<li><p><a class="reference internal" href="types.html#int"><span class="std std-ref">Integer</span></a> literals: These are sequences of decimal digits (<code class="docutils literal notranslate"><span class="pre">0</span></code> through <code class="docutils literal notranslate"><span class="pre">9</span></code>),
possibly starting with a minus sign (<code class="docutils literal notranslate"><span class="pre">-</span></code>).
For example:</p>
<div class="highlight-ql notranslate"><div class="highlight"><pre><span></span>0
42
-2048
</pre></div>
</div>
</li>
<li><p><a class="reference internal" href="types.html#float"><span class="std std-ref">Float</span></a> literals: These are sequences of decimal digits separated by a dot
(<code class="docutils literal notranslate"><span class="pre">.</span></code>), possibly starting with a minus sign (<code class="docutils literal notranslate"><span class="pre">-</span></code>).
For example:</p>
<div class="highlight-ql notranslate"><div class="highlight"><pre><span></span>2.0
123.456
-100.5
</pre></div>
</div>
</li>
<li><p><a class="reference internal" href="types.html#string"><span class="std std-ref">String</span></a> literals: These are finite strings of 16-bit characters. You can
define a string literal by enclosing characters in quotation marks (<code class="docutils literal notranslate"><span class="pre">&quot;...&quot;</span></code>). Most
characters represent themselves, but there are a few characters that you need to “escape”
with a backslash. The following are examples of string literals:</p>
<div class="highlight-ql notranslate"><div class="highlight"><pre><span></span>&quot;hello&quot;
&quot;They said, \&quot;Please escape quotation marks!\&quot;&quot;
</pre></div>
</div>
<p>See <a class="reference external" href="https://codeql.github.com/docs/ql-language-reference/ql-language-specification/#string-literals-string">String literals</a>
in the QL language specification for more details.</p>
<p>Note: there is no “date literal” in QL. Instead, to specify a <a class="reference internal" href="types.html#date"><span class="std std-ref">date</span></a>, you should
convert a string to the date that it represents using the <code class="docutils literal notranslate"><span class="pre">toDate()</span></code> predicate. For example,
<code class="docutils literal notranslate"><span class="pre">&quot;2016-04-03&quot;.toDate()</span></code> is the date April 3, 2016, and <code class="docutils literal notranslate"><span class="pre">&quot;2000-01-01</span> <span class="pre">00:00:01&quot;.toDate()</span></code> is the
point in time one second after New Year 2000.</p>
<dl class="simple">
<dt>The following string formats are recognized as dates:</dt><dd><ul class="simple">
<li><p><strong>ISO dates</strong>, such as <code class="docutils literal notranslate"><span class="pre">&quot;2016-04-03</span> <span class="pre">17:00:24&quot;</span></code>. The seconds part is optional (assumed
to be <code class="docutils literal notranslate"><span class="pre">&quot;00&quot;</span></code> if it’s missing), and the entire time part can also be missing (in which
case it’s assumed to be <code class="docutils literal notranslate"><span class="pre">&quot;00:00:00&quot;</span></code>).</p></li>
<li><p><strong>Short-hand ISO dates</strong>, such as <code class="docutils literal notranslate"><span class="pre">&quot;20160403&quot;</span></code>.</p></li>
<li><p><strong>UK-style dates</strong>, such as <code class="docutils literal notranslate"><span class="pre">&quot;03/04/2016&quot;</span></code>.</p></li>
<li><p><strong>Verbose dates</strong>, such as <code class="docutils literal notranslate"><span class="pre">&quot;03</span> <span class="pre">April</span> <span class="pre">2016&quot;</span></code>.</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</section>
<section id="parenthesized-expressions">
<h2>Parenthesized expressions<a class="headerlink" href="#parenthesized-expressions" title="Link to this heading">¶</a></h2>
<p>A parenthesized expression is an expression surrounded by parentheses, <code class="docutils literal notranslate"><span class="pre">(</span></code> and <code class="docutils literal notranslate"><span class="pre">)</span></code>. This
expression has exactly the same type and values as the original expression.
Parentheses are useful for grouping expressions together to remove ambiguity and improve
readability.</p>
</section>
<section id="ranges">
<span id="index-1"></span><span id="id2"></span><h2>Ranges<a class="headerlink" href="#ranges" title="Link to this heading">¶</a></h2>
<p>A range expression denotes a range of values ordered between two expressions. It consists of
two expressions separated by <code class="docutils literal notranslate"><span class="pre">..</span></code> and enclosed in brackets (<code class="docutils literal notranslate"><span class="pre">[</span></code> and <code class="docutils literal notranslate"><span class="pre">]</span></code>).
For example, <code class="docutils literal notranslate"><span class="pre">[3</span> <span class="pre">..</span> <span class="pre">7]</span></code> is a valid range expression. Its values are any integers between
<code class="docutils literal notranslate"><span class="pre">3</span></code> and <code class="docutils literal notranslate"><span class="pre">7</span></code> (including <code class="docutils literal notranslate"><span class="pre">3</span></code> and <code class="docutils literal notranslate"><span class="pre">7</span></code> themselves).</p>
<p>In a valid range, the start and end expression are integers, floats, or dates. If one of them
is a date, then both must be dates. If one of them is an integer and the other a float, then
both are treated as floats.</p>
</section>
<section id="set-literal-expressions">
<span id="setliteral"></span><span id="index-2"></span><h2>Set literal expressions<a class="headerlink" href="#set-literal-expressions" title="Link to this heading">¶</a></h2>
<p>A set literal expression allows the explicit listing of a choice between several values.
It consists of a comma-separated collection of expressions that are enclosed in brackets (<code class="docutils literal notranslate"><span class="pre">[</span></code> and <code class="docutils literal notranslate"><span class="pre">]</span></code>).
For example, <code class="docutils literal notranslate"><span class="pre">[2,</span> <span class="pre">3,</span> <span class="pre">5,</span> <span class="pre">7,</span> <span class="pre">11,</span> <span class="pre">13,</span> <span class="pre">17,</span> <span class="pre">19,</span> <span class="pre">23,</span> <span class="pre">29]</span></code> is a valid set literal expression.
Its values are the first ten prime numbers.</p>
<p>The values of the contained expressions need to be of <a class="reference internal" href="types.html#type-compatibility"><span class="std std-ref">compatible types</span></a> for a valid set literal expression.
Furthermore, at least one of the set elements has to be of a type that is a supertype of the types of all
the other contained expressions.</p>
<p>Set literals are supported from release 2.1.0 of the CodeQL CLI, and release 1.24 of LGTM Enterprise.</p>
</section>
<section id="super-expressions">
<span id="super"></span><span id="index-3"></span><h2>Super expressions<a class="headerlink" href="#super-expressions" title="Link to this heading">¶</a></h2>
<p>Super expressions in QL are similar to super expressions in other programming languages, such
as Java. You can use them in predicate calls, when you want to use the predicate definition
from a supertype. In practice, this is useful when a predicate inherits two definitions from
its supertypes. In that case, the predicate must <a class="reference internal" href="types.html#overriding-member-predicates"><span class="std std-ref">override</span></a>
those definitions to avoid ambiguity.
However, if you want to use the definition from a particular supertype instead of writing a
new definition, you can use a super expression.</p>
<p>In the following example, the class <code class="docutils literal notranslate"><span class="pre">C</span></code> inherits two definitions of the predicate
<code class="docutils literal notranslate"><span class="pre">getANumber()</span></code>—one from <code class="docutils literal notranslate"><span class="pre">A</span></code> and one from <code class="docutils literal notranslate"><span class="pre">B</span></code>.
Instead of overriding both definitions, it uses the definition from <code class="docutils literal notranslate"><span class="pre">B</span></code>.</p>
<div class="highlight-ql notranslate"><div class="highlight"><pre><span></span>class A extends int {
  A() { this = 1 }
  int getANumber() { result = 2 }
}

class B extends int {
  B() { this = 1 }
  int getANumber() { result = 3 }
}

class C extends A, B {
  // Need to define `int getANumber()`; otherwise it would be ambiguous
  int getANumber() {
    result = B.super.getANumber()
  }
}

from C c
select c, c.getANumber()
</pre></div>
</div>
<p>The result of this query is <code class="docutils literal notranslate"><span class="pre">1,</span> <span class="pre">3</span></code>.</p>
</section>
<section id="calls-to-predicates-with-result">
<span id="calls-with-result"></span><h2>Calls to predicates (with result)<a class="headerlink" href="#calls-to-predicates-with-result" title="Link to this heading">¶</a></h2>
<p>Calls to <a class="reference internal" href="predicates.html#predicates-with-result"><span class="std std-ref">predicates with results</span></a> are themselves expressions,
unlike calls to <a class="reference internal" href="predicates.html#predicates-without-result"><span class="std std-ref">predicates without results</span></a> which are
formulas. For more information, see “<a class="reference internal" href="formulas.html#calls"><span class="std std-ref">Calls to predicates</span></a>.”</p>
<p>A call to a predicate with result evaluates to the values of the <code class="docutils literal notranslate"><span class="pre">result</span></code> variable of the
called predicate.</p>
<p>For example <code class="docutils literal notranslate"><span class="pre">a.getAChild()</span></code> is a call to a predicate <code class="docutils literal notranslate"><span class="pre">getAChild()</span></code> on a variable <code class="docutils literal notranslate"><span class="pre">a</span></code>.
This call evaluates to the set of children of <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
</section>
<section id="aggregations">
<span id="index-4"></span><span id="id3"></span><h2>Aggregations<a class="headerlink" href="#aggregations" title="Link to this heading">¶</a></h2>
<p>An aggregation is a mapping that computes a result value from a set of input values that are
specified by a formula.</p>
<p>The general syntax is:</p>
<div class="highlight-ql notranslate"><div class="highlight"><pre><span></span>&lt;aggregate&gt;(&lt;variable declarations&gt; | &lt;formula&gt; | &lt;expression&gt;)
</pre></div>
</div>
<p>The variables <a class="reference internal" href="variables.html#variable-declarations"><span class="std std-ref">declared</span></a> in <code class="docutils literal notranslate"><span class="pre">&lt;variable</span> <span class="pre">declarations&gt;</span></code> are called
the <strong>aggregation variables</strong>.</p>
<p>Ordered aggregates (namely <code class="docutils literal notranslate"><span class="pre">min</span></code>, <code class="docutils literal notranslate"><span class="pre">max</span></code>, <code class="docutils literal notranslate"><span class="pre">rank</span></code>, <code class="docutils literal notranslate"><span class="pre">concat</span></code>, and <code class="docutils literal notranslate"><span class="pre">strictconcat</span></code>) are
ordered by their <code class="docutils literal notranslate"><span class="pre">&lt;expression&gt;</span></code> values by default. The ordering is either numeric (for
integers and floating point numbers) or lexicographic (for strings). Lexicographic ordering is
based on the <a class="reference external" href="https://en.wikipedia.org/wiki/List_of_Unicode_characters#Basic_Latin">Unicode value</a>
of each character.</p>
<p>To specify a different order, follow <code class="docutils literal notranslate"><span class="pre">&lt;expression&gt;</span></code> with the keywords <code class="docutils literal notranslate"><span class="pre">order</span> <span class="pre">by</span></code>, then
one or more comma-separated expressions that specify the order, and optionally the keyword <code class="docutils literal notranslate"><span class="pre">asc</span></code> or <code class="docutils literal notranslate"><span class="pre">desc</span></code> after each expression
(to determine whether to order the expression in ascending or descending order). If you don’t
specify an ordering, it defaults to <code class="docutils literal notranslate"><span class="pre">asc</span></code>. For example, <code class="docutils literal notranslate"><span class="pre">order</span> <span class="pre">by</span> <span class="pre">o.getName()</span> <span class="pre">asc,</span> <span class="pre">o.getSize()</span> <span class="pre">desc</span></code>
might be used to order some object by name, breaking ties by descending size.</p>
<p>The following aggregates are available in QL:</p>
<ul id="index-5">
<li><p><code class="docutils literal notranslate"><span class="pre">count</span></code>: This aggregate determines the number of distinct values of <code class="docutils literal notranslate"><span class="pre">&lt;expression&gt;</span></code> for
each possible assignment of the aggregation variables.</p>
<p>For example, the following aggregation returns the number of files that have more than
<code class="docutils literal notranslate"><span class="pre">500</span></code> lines:</p>
<div class="highlight-ql notranslate"><div class="highlight"><pre><span></span>count(File f | f.getTotalNumberOfLines() &gt; 500 | f)
</pre></div>
</div>
<p>If there are no possible assignments to the aggregation variables that satisfy the formula, as in
<code class="docutils literal notranslate"><span class="pre">count(int</span> <span class="pre">i</span> <span class="pre">|</span> <span class="pre">i</span> <span class="pre">=</span> <span class="pre">1</span> <span class="pre">and</span> <span class="pre">i</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">|</span> <span class="pre">i)</span></code>, then <code class="docutils literal notranslate"><span class="pre">count</span></code> defaults to the value <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
</li>
</ul>
<ul id="index-6">
<li><p><code class="docutils literal notranslate"><span class="pre">min</span></code> and <code class="docutils literal notranslate"><span class="pre">max</span></code>: These aggregates determine the smallest (<code class="docutils literal notranslate"><span class="pre">min</span></code>) or largest (<code class="docutils literal notranslate"><span class="pre">max</span></code>)
value of <code class="docutils literal notranslate"><span class="pre">&lt;expression&gt;</span></code> among the possible assignments to the aggregation variables.
In this case, <code class="docutils literal notranslate"><span class="pre">&lt;expression&gt;</span></code> must be of numeric type or of type <code class="docutils literal notranslate"><span class="pre">string</span></code>.</p>
<p>For example, the following aggregation returns the name of the <code class="docutils literal notranslate"><span class="pre">.js</span></code> file (or files) with the
largest number of lines, using the number of lines of code to break ties:</p>
<div class="highlight-ql notranslate"><div class="highlight"><pre><span></span>max(File f | f.getExtension() = &quot;js&quot; | f.getBaseName() order by f.getTotalNumberOfLines(), f.getNumberOfLinesOfCode())
</pre></div>
</div>
<p>The following aggregation returns the minimum string <code class="docutils literal notranslate"><span class="pre">s</span></code> out of the three strings mentioned
below, that is, the string that comes first in the lexicographic ordering of all the possible
values of <code class="docutils literal notranslate"><span class="pre">s</span></code>. (In this case, it returns <code class="docutils literal notranslate"><span class="pre">&quot;De</span> <span class="pre">Morgan&quot;</span></code>.)</p>
<div class="highlight-ql notranslate"><div class="highlight"><pre><span></span>min(string s | s = &quot;Tarski&quot; or s = &quot;Dedekind&quot; or s = &quot;De Morgan&quot; | s)
</pre></div>
</div>
</li>
</ul>
<ul id="index-7">
<li><p><code class="docutils literal notranslate"><span class="pre">avg</span></code>: This aggregate determines the average value of <code class="docutils literal notranslate"><span class="pre">&lt;expression&gt;</span></code> for all possible
assignments to the aggregation variables. The type of <code class="docutils literal notranslate"><span class="pre">&lt;expression&gt;</span></code> must be numeric.
If there are no possible assignments to the aggregation variables that satisfy the formula, the aggregation fails and
returns no values. In other words, it evaluates to the empty set.</p>
<p>For example, the following aggregation returns the average of the integers <code class="docutils literal notranslate"><span class="pre">0</span></code>, <code class="docutils literal notranslate"><span class="pre">1</span></code>,
<code class="docutils literal notranslate"><span class="pre">2</span></code>, and <code class="docutils literal notranslate"><span class="pre">3</span></code>:</p>
<div class="highlight-ql notranslate"><div class="highlight"><pre><span></span>avg(int i | i = [0 .. 3] | i)
</pre></div>
</div>
</li>
</ul>
<ul id="index-8">
<li><p><code class="docutils literal notranslate"><span class="pre">sum</span></code>: This aggregate determines the sum of the values of <code class="docutils literal notranslate"><span class="pre">&lt;expression&gt;</span></code> over all possible
assignments to the aggregation variables. The type of <code class="docutils literal notranslate"><span class="pre">&lt;expression&gt;</span></code> must be numeric.
If there are no possible assignments to the aggregation variables that satisfy the formula, then the sum is <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
<p>For example, the following aggregation returns the sum of <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">*</span> <span class="pre">j</span></code> for all possible values
of <code class="docutils literal notranslate"><span class="pre">i</span></code> and <code class="docutils literal notranslate"><span class="pre">j</span></code>:</p>
<div class="highlight-ql notranslate"><div class="highlight"><pre><span></span>sum(int i, int j | i = [0 .. 2] and j = [3 .. 5] | i * j)
</pre></div>
</div>
</li>
</ul>
<ul id="index-9">
<li><p><code class="docutils literal notranslate"><span class="pre">concat</span></code>: This aggregate concatenates the values of <code class="docutils literal notranslate"><span class="pre">&lt;expression&gt;</span></code> over all possible
assignments to the aggregation variables. Note that <code class="docutils literal notranslate"><span class="pre">&lt;expression&gt;</span></code> must be of type
<code class="docutils literal notranslate"><span class="pre">string</span></code>. If there are no possible assignments to the aggregation variables that satisfy
the formula, then <code class="docutils literal notranslate"><span class="pre">concat</span></code> defaults to the empty string.</p>
<p>For example, the following aggregation returns the string <code class="docutils literal notranslate"><span class="pre">&quot;3210&quot;</span></code>, that is, the
concatenation of the strings <code class="docutils literal notranslate"><span class="pre">&quot;0&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;1&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;2&quot;</span></code>, and <code class="docutils literal notranslate"><span class="pre">&quot;3&quot;</span></code> in descending order:</p>
<div class="highlight-ql notranslate"><div class="highlight"><pre><span></span>concat(int i | i = [0 .. 3] | i.toString() order by i desc)
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">concat</span></code> aggregate can also take a second expression, separated from the first one by
a comma. This second expression is inserted as a separator between each concatenated value.</p>
<p>For example, the following aggregation returns <code class="docutils literal notranslate"><span class="pre">&quot;0|1|2|3&quot;</span></code>:</p>
<div class="highlight-ql notranslate"><div class="highlight"><pre><span></span>concat(int i | i = [0 .. 3] | i.toString(), &quot;|&quot;)
</pre></div>
</div>
</li>
</ul>
<ul id="index-10">
<li><p><code class="docutils literal notranslate"><span class="pre">rank</span></code>: This aggregate takes the possible values of <code class="docutils literal notranslate"><span class="pre">&lt;expression&gt;</span></code> and ranks them.
In this case, <code class="docutils literal notranslate"><span class="pre">&lt;expression&gt;</span></code> must be of numeric type or of type <code class="docutils literal notranslate"><span class="pre">string</span></code>. The aggregation
returns the value that is ranked in the position specified by the <strong>rank expression</strong>.
You must include this rank expression in brackets after the keyword <code class="docutils literal notranslate"><span class="pre">rank</span></code>.</p>
<p>For example, the following aggregation returns the value that is ranked 4th out of all the
possible values. In this case, <code class="docutils literal notranslate"><span class="pre">8</span></code> is the 4th integer in the range from <code class="docutils literal notranslate"><span class="pre">5</span></code> through
<code class="docutils literal notranslate"><span class="pre">15</span></code>:</p>
<div class="highlight-ql notranslate"><div class="highlight"><pre><span></span>rank[4](int i | i = [5 .. 15] | i)
</pre></div>
</div>
<blockquote class="pull-quote">
<div><p>Note</p>
<ul class="simple">
<li><p>Rank indices start at <code class="docutils literal notranslate"><span class="pre">1</span></code>, so <code class="docutils literal notranslate"><span class="pre">rank[0](...)</span></code> has no result.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rank[1](...)</span></code> is the same as <code class="docutils literal notranslate"><span class="pre">min(...)</span></code>.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
<ul class="simple" id="index-11">
<li><p><code class="docutils literal notranslate"><span class="pre">strictconcat</span></code>, <code class="docutils literal notranslate"><span class="pre">strictcount</span></code>, and <code class="docutils literal notranslate"><span class="pre">strictsum</span></code>: These aggregates work like <code class="docutils literal notranslate"><span class="pre">concat</span></code>,
<code class="docutils literal notranslate"><span class="pre">count</span></code>, and <code class="docutils literal notranslate"><span class="pre">sum</span></code> respectively, except that they are <em>strict</em>. That is, if there are no
possible assignments to the aggregation variables that satisfy the formula, then the entire aggregation fails and
evaluates to the empty set (instead of defaulting to <code class="docutils literal notranslate"><span class="pre">0</span></code> or the empty string).
This is useful if you’re only interested in results where the aggregation body is non-trivial.</p></li>
</ul>
<ul id="index-12">
<li><p><code class="docutils literal notranslate"><span class="pre">unique</span></code>: This aggregate depends on the values of <code class="docutils literal notranslate"><span class="pre">&lt;expression&gt;</span></code> over all possible assignments to
the aggregation variables. If there is a unique value of <code class="docutils literal notranslate"><span class="pre">&lt;expression&gt;</span></code> over the aggregation variables,
then the aggregate evaluates to that value.
Otherwise, the aggregate has no value.</p>
<p>For example, the following query returns the positive integers <code class="docutils literal notranslate"><span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">2</span></code>, <code class="docutils literal notranslate"><span class="pre">3</span></code>, <code class="docutils literal notranslate"><span class="pre">4</span></code>, <code class="docutils literal notranslate"><span class="pre">5</span></code>.
For negative integers <code class="docutils literal notranslate"><span class="pre">x</span></code>, the expressions <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">x.abs()</span></code> have different values, so the
value for <code class="docutils literal notranslate"><span class="pre">y</span></code> in the aggregate expression is not uniquely determined.</p>
<div class="highlight-ql notranslate"><div class="highlight"><pre><span></span>from int x
where x in [-5 .. 5] and x != 0
select unique(int y | y = x or y = x.abs() | y)
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">unique</span></code> aggregate is supported from release 2.1.0 of the CodeQL CLI, and release 1.24 of LGTM Enterprise.</p>
</li>
</ul>
<section id="evaluation-of-aggregates">
<h3>Evaluation of aggregates<a class="headerlink" href="#evaluation-of-aggregates" title="Link to this heading">¶</a></h3>
<p>In general, aggregate evaluation involves the following steps:</p>
<ol class="arabic simple">
<li><p>Determine the input variables: these are the aggregation variables declared in <code class="docutils literal notranslate"><span class="pre">&lt;variable</span> <span class="pre">declarations&gt;</span></code> and
also the variables declared outside of the aggregate that are used in some component of the aggregate.</p></li>
<li><p>Generate all possible distinct tuples (combinations) of the values of input variables such that the
<code class="docutils literal notranslate"><span class="pre">&lt;formula&gt;</span></code> holds true. Note that the same value of an aggregate variable may appear in
multiple distinct tuples. All such occurrences of the same value are treated as distinct occurrences
when processing tuples.</p></li>
<li><p>Apply <code class="docutils literal notranslate"><span class="pre">&lt;expression&gt;</span></code> on each tuple and collect the generated (distinct) values. The application
of <code class="docutils literal notranslate"><span class="pre">&lt;expression&gt;</span></code> on a tuple may result in generating more than one value.</p></li>
<li><p>Apply the aggregation function on the values generated in step 3 to compute the final result.</p></li>
</ol>
<p>Let us apply these steps to the <code class="docutils literal notranslate"><span class="pre">sum</span></code> aggregate in the following query:</p>
<div class="highlight-ql notranslate"><div class="highlight"><pre><span></span>select sum(int i, int j |
    exists(string s | s = &quot;hello&quot;.charAt(i)) and exists(string s | s = &quot;world!&quot;.charAt(j)) | i)
</pre></div>
</div>
<ol class="arabic">
<li><p>Input variables: <code class="docutils literal notranslate"><span class="pre">i</span></code>, <code class="docutils literal notranslate"><span class="pre">j</span></code>.</p></li>
<li><p>All possible tuples <code class="docutils literal notranslate"><span class="pre">(&lt;value</span> <span class="pre">of</span> <span class="pre">i&gt;,</span> <span class="pre">&lt;value</span> <span class="pre">of</span> <span class="pre">j&gt;)</span></code> satisfying the given condition:
<code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">0),</span> <span class="pre">(0,</span> <span class="pre">1),</span> <span class="pre">(0,</span> <span class="pre">2),</span> <span class="pre">(0,</span> <span class="pre">3),</span> <span class="pre">(0,</span> <span class="pre">4),</span> <span class="pre">(0,</span> <span class="pre">5),</span> <span class="pre">(1,</span> <span class="pre">0),</span> <span class="pre">(1,</span> <span class="pre">1),</span> <span class="pre">...,</span> <span class="pre">(4,</span> <span class="pre">5)</span></code>.</p>
<p>30 tuples are generated in this step.</p>
</li>
<li><p>Apply the <code class="docutils literal notranslate"><span class="pre">&lt;expression&gt;</span> <span class="pre">i</span></code> on all tuples. This means selecting all values of <code class="docutils literal notranslate"><span class="pre">i</span></code> from
all tuples: <code class="docutils literal notranslate"><span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">2,</span> <span class="pre">2,</span> <span class="pre">2,</span> <span class="pre">2,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">3,</span> <span class="pre">3,</span> <span class="pre">3,</span> <span class="pre">3,</span> <span class="pre">3,</span> <span class="pre">4,</span> <span class="pre">4,</span> <span class="pre">4,</span> <span class="pre">4,</span> <span class="pre">4,</span> <span class="pre">4.</span></code></p></li>
<li><p>Apply the aggregation function <code class="docutils literal notranslate"><span class="pre">sum</span></code> on the above values to get the final result <code class="docutils literal notranslate"><span class="pre">60</span></code>.</p></li>
</ol>
<p>If we change <code class="docutils literal notranslate"><span class="pre">&lt;expression&gt;</span></code> to <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">+</span> <span class="pre">j</span></code> in the above query, the query result is <code class="docutils literal notranslate"><span class="pre">135</span></code> since
applying <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">+</span> <span class="pre">j</span></code> on all tuples results in following values:
<code class="docutils literal notranslate"><span class="pre">0,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4,</span> <span class="pre">5,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4,</span> <span class="pre">5,</span> <span class="pre">6,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4,</span> <span class="pre">5,</span> <span class="pre">6,</span> <span class="pre">7,</span> <span class="pre">3,</span> <span class="pre">4,</span> <span class="pre">5,</span> <span class="pre">6,</span> <span class="pre">7,</span> <span class="pre">8,</span> <span class="pre">4,</span> <span class="pre">5,</span> <span class="pre">6,</span> <span class="pre">7,</span> <span class="pre">8,</span> <span class="pre">9</span></code>.</p>
<p>Next, consider the following query:</p>
<div class="highlight-ql notranslate"><div class="highlight"><pre><span></span>select count(string s | s = &quot;hello&quot; | s.charAt(_))
</pre></div>
</div>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">s</span></code> is the input variable of the aggregate.</p></li>
<li><p>A single tuple <code class="docutils literal notranslate"><span class="pre">&quot;hello&quot;</span></code> is generated in this step.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">&lt;expression&gt;</span> <span class="pre">charAt(_)</span></code> is applied on this tuple. The underscore <code class="docutils literal notranslate"><span class="pre">_</span></code> in <code class="docutils literal notranslate"><span class="pre">charAt(_)</span></code>
is a <a class="reference internal" href="#don-t-care-expressions"><span class="std std-ref">don’t-care expression</span></a>, which represents any value.
<code class="docutils literal notranslate"><span class="pre">s.charAt(_)</span></code> generates four distinct values <code class="docutils literal notranslate"><span class="pre">h,</span> <span class="pre">e,</span> <span class="pre">l,</span> <span class="pre">o</span></code>.</p></li>
<li><p>Finally, <code class="docutils literal notranslate"><span class="pre">count</span></code> is applied on these values, and the query returns <code class="docutils literal notranslate"><span class="pre">4</span></code>.</p></li>
</ol>
</section>
<section id="omitting-parts-of-an-aggregation">
<h3>Omitting parts of an aggregation<a class="headerlink" href="#omitting-parts-of-an-aggregation" title="Link to this heading">¶</a></h3>
<p>The three parts of an aggregation are not always required, so you can often write the
aggregation in a simpler form:</p>
<ol class="arabic">
<li><p>If you want to write an aggregation of the form <code class="docutils literal notranslate"><span class="pre">&lt;aggregate&gt;(&lt;type&gt;</span> <span class="pre">v</span> <span class="pre">|</span> <span class="pre">&lt;expression&gt;</span> <span class="pre">=</span> <span class="pre">v</span> <span class="pre">|</span> <span class="pre">v)</span></code>,
then you can omit the <code class="docutils literal notranslate"><span class="pre">&lt;variable</span> <span class="pre">declarations&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">&lt;formula&gt;</span></code> parts and write it
as follows:</p>
<div class="highlight-ql notranslate"><div class="highlight"><pre><span></span>&lt;aggregate&gt;(&lt;expression&gt;)
</pre></div>
</div>
<p>For example, the following aggregations determine how many times the letter <code class="docutils literal notranslate"><span class="pre">l</span></code> occurs in
string <code class="docutils literal notranslate"><span class="pre">&quot;hello&quot;</span></code>. These forms are equivalent:</p>
<div class="highlight-ql notranslate"><div class="highlight"><pre><span></span>count(int i | i = &quot;hello&quot;.indexOf(&quot;l&quot;) | i)
count(&quot;hello&quot;.indexOf(&quot;l&quot;))
</pre></div>
</div>
</li>
<li><p>If there is only one aggregation variable, you can omit the <code class="docutils literal notranslate"><span class="pre">&lt;expression&gt;</span></code> part instead.
In this case, the expression is considered to be the aggregation variable itself.
For example, the following aggregations are equivalent:</p>
<div class="highlight-ql notranslate"><div class="highlight"><pre><span></span>avg(int i | i = [0 .. 3] | i)
avg(int i | i = [0 .. 3])
</pre></div>
</div>
</li>
<li><p>As a special case, you can omit the <code class="docutils literal notranslate"><span class="pre">&lt;expression&gt;</span></code> part from <code class="docutils literal notranslate"><span class="pre">count</span></code> even if there is more
than one aggregation variable. In such a case, it counts the number of distinct tuples of
aggregation variables that satisfy the formula. In other words, the expression part is
considered to be the constant <code class="docutils literal notranslate"><span class="pre">1</span></code>. For example, the following aggregations are equivalent:</p>
<div class="highlight-ql notranslate"><div class="highlight"><pre><span></span>count(int i, int j | i in [1 .. 3] and j in [1 .. 3] | 1)
count(int i, int j | i in [1 .. 3] and j in [1 .. 3])
</pre></div>
</div>
</li>
<li><p>You can omit the <code class="docutils literal notranslate"><span class="pre">&lt;formula&gt;</span></code> part, but in that case you should include two vertical bars:</p>
<div class="highlight-ql notranslate"><div class="highlight"><pre><span></span>&lt;aggregate&gt;(&lt;variable declarations&gt; | | &lt;expression&gt;)
</pre></div>
</div>
<p>This is useful if you don’t want to restrict the aggregation variables any further.
For example, the following aggregation returns the maximum number of lines across all files:</p>
<div class="highlight-ql notranslate"><div class="highlight"><pre><span></span>max(File f | | f.getTotalNumberOfLines())
</pre></div>
</div>
</li>
<li><p>Finally, you can also omit both the <code class="docutils literal notranslate"><span class="pre">&lt;formula&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">&lt;expression&gt;</span></code> parts. For example,
the following aggregations are equivalent ways to count the number of files in a database:</p>
<div class="highlight-ql notranslate"><div class="highlight"><pre><span></span>count(File f | any() | 1)
count(File f | | 1)
count(File f)
</pre></div>
</div>
</li>
</ol>
</section>
<section id="monotonic-aggregates">
<span id="id4"></span><h3>Monotonic aggregates<a class="headerlink" href="#monotonic-aggregates" title="Link to this heading">¶</a></h3>
<p>In addition to standard aggregates, QL also supports monotonic aggregates.
Monotonic aggregates differ from standard aggregates in the way that they deal with the
values generated by the <code class="docutils literal notranslate"><span class="pre">&lt;expression&gt;</span></code> part of the formula:</p>
<ul class="simple">
<li><p>Standard aggregates take the <code class="docutils literal notranslate"><span class="pre">&lt;expression&gt;</span></code> values for each <code class="docutils literal notranslate"><span class="pre">&lt;formula&gt;</span></code> value and
flatten them into a list. A single aggregation function is applied to all the values.</p></li>
<li><p>Monotonic aggregates take an <code class="docutils literal notranslate"><span class="pre">&lt;expression&gt;</span></code> for each value given by the <code class="docutils literal notranslate"><span class="pre">&lt;formula&gt;</span></code>,
and create combinations of all the possible values. The aggregation
function is applied to each of the resulting combinations.</p></li>
</ul>
<p>In general, if the <code class="docutils literal notranslate"><span class="pre">&lt;expression&gt;</span></code> is total and functional, then monotonic aggregates are
equivalent to standard aggregates. Results differ when there is not precisely one <code class="docutils literal notranslate"><span class="pre">&lt;expression&gt;</span></code>
value for each value generated by the <code class="docutils literal notranslate"><span class="pre">&lt;formula&gt;</span></code>:</p>
<ul class="simple">
<li><p>If there are missing <code class="docutils literal notranslate"><span class="pre">&lt;expression&gt;</span></code> values (that is, there is no
<code class="docutils literal notranslate"><span class="pre">&lt;expression&gt;</span></code> value for a value generated by the <code class="docutils literal notranslate"><span class="pre">&lt;formula&gt;</span></code>), monotonic aggregates
won’t compute a result, as you cannot create combinations of values
including exactly one <code class="docutils literal notranslate"><span class="pre">&lt;expression&gt;</span></code> value for each value generated by the <code class="docutils literal notranslate"><span class="pre">&lt;formula&gt;</span></code>.</p></li>
<li><p>If there is more than one <code class="docutils literal notranslate"><span class="pre">&lt;expression&gt;</span></code> per <code class="docutils literal notranslate"><span class="pre">&lt;formula&gt;</span></code> result, you can create multiple
combinations of values including exactly one <code class="docutils literal notranslate"><span class="pre">&lt;expression&gt;</span></code> value for each
value generated by the <code class="docutils literal notranslate"><span class="pre">&lt;formula&gt;</span></code>. Here, the aggregation function is applied to each of the
resulting combinations.</p></li>
</ul>
<section id="example-of-monotonic-aggregates">
<h4>Example of monotonic aggregates<a class="headerlink" href="#example-of-monotonic-aggregates" title="Link to this heading">¶</a></h4>
<p>Consider this query:</p>
<div class="highlight-ql notranslate"><div class="highlight"><pre><span></span>string getPerson() { result = &quot;Alice&quot; or
                     result = &quot;Bob&quot; or
                     result = &quot;Charles&quot; or
                     result = &quot;Diane&quot;
                   }
string getFruit(string p) { p = &quot;Alice&quot;   and result = &quot;Orange&quot; or
                            p = &quot;Alice&quot;   and result = &quot;Apple&quot; or
                            p = &quot;Bob&quot;     and result = &quot;Apple&quot; or
                            p = &quot;Charles&quot; and result = &quot;Apple&quot; or
                            p = &quot;Charles&quot; and result = &quot;Banana&quot;
                          }
int getPrice(string f) { f = &quot;Apple&quot;  and result = 100 or
                         f = &quot;Orange&quot; and result = 100 or
                         f = &quot;Orange&quot; and result =   1
                       }

predicate nonmono(string p, int cost) {
  p = getPerson() and cost = sum(string f | f = getFruit(p) | getPrice(f))
}

language[monotonicAggregates]
predicate mono(string p, int cost) {
  p = getPerson() and cost = sum(string f | f = getFruit(p) | getPrice(f))
}

from string variant, string person, int cost
where variant = &quot;default&quot;  and nonmono(person, cost) or
      variant = &quot;monotonic&quot; and mono(person, cost)
select variant, person, cost
order by variant, person
</pre></div>
</div>
<p>The query produces these results:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>variant</p></th>
<th class="head"><p>person</p></th>
<th class="head"><p>cost</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>default</p></td>
<td><p>Alice</p></td>
<td><p>201</p></td>
</tr>
<tr class="row-odd"><td><p>default</p></td>
<td><p>Bob</p></td>
<td><p>100</p></td>
</tr>
<tr class="row-even"><td><p>default</p></td>
<td><p>Charles</p></td>
<td><p>100</p></td>
</tr>
<tr class="row-odd"><td><p>default</p></td>
<td><p>Diane</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-even"><td><p>monotonic</p></td>
<td><p>Alice</p></td>
<td><p>101</p></td>
</tr>
<tr class="row-odd"><td><p>monotonic</p></td>
<td><p>Alice</p></td>
<td><p>200</p></td>
</tr>
<tr class="row-even"><td><p>monotonic</p></td>
<td><p>Bob</p></td>
<td><p>100</p></td>
</tr>
<tr class="row-odd"><td><p>monotonic</p></td>
<td><p>Diane</p></td>
<td><p>0</p></td>
</tr>
</tbody>
</table>
<p>The two variants of the aggregate semantics differ in what happens
when <code class="docutils literal notranslate"><span class="pre">getPrice(f)</span></code> has either multiple results or no results
for a given <code class="docutils literal notranslate"><span class="pre">f</span></code>.</p>
<p>In this query, oranges are available at two different prices, and the
default <code class="docutils literal notranslate"><span class="pre">sum</span></code> aggregate returns a single line where Alice buys an
orange at a price of 100, another orange at a price of 1, and an apple
at a price of 100, totalling 201. On the other hand, in the the
<em>monotonic</em> semantics for <code class="docutils literal notranslate"><span class="pre">sum</span></code>, Alice always buys one orange and
one apple, and a line of output is produced for each <em>way</em> she can
complete her shopping list.</p>
<p>If there had been two different prices for apples too, the monotonic
<code class="docutils literal notranslate"><span class="pre">sum</span></code> would have produced <em>four</em> output lines for Alice.</p>
<p>Charles wants to buy a banana, which is not for sale at all. In the
default case, the sum produced for Charles includes the cost of the
apple he <em>can</em> buy, but there’s no line for Charles in the monontonic
<code class="docutils literal notranslate"><span class="pre">sum</span></code> output, because there <em>is no way</em> for Charles to buy one apple
plus one banana.</p>
<p>(Diane buys no fruit at all, and in both variants her total cost
is 0. The <code class="docutils literal notranslate"><span class="pre">strictsum</span></code> aggregate would have excluded her from the
results in both cases).</p>
<p>In actual QL practice, it is quite rare to use monotonic aggregates
with the <em>goal</em> of having multiple output lines, as in the “Alice”
case of this example. The more significant point is the “Charles”
case: As long as there’s no price for bananas, no output is produced
for him. This means that if we later do learn of a banana price, we
don’t need to <em>remove</em> any output tuple already produced. The
importance of this is that the monotonic aggregate behavior works well
with a fixpoint-based semantics for recursion, so it will be meaningul
to let the <code class="docutils literal notranslate"><span class="pre">getPrice</span></code> predicate be mutually recursive with the count
aggregate itself. (On the other hand, <code class="docutils literal notranslate"><span class="pre">getFruit</span></code> still cannot be
allowed to be recursive, because adding another fruit to someone’s
shopping list would invalidate the total costs we already knew for
them).</p>
<p>This opportunity to use recursion is the main practical reason for
requesting monotonic semantics of aggregates.</p>
</section>
<section id="recursive-monotonic-aggregates">
<h4>Recursive monotonic aggregates<a class="headerlink" href="#recursive-monotonic-aggregates" title="Link to this heading">¶</a></h4>
<p>Monotonic aggregates may be used <a class="reference internal" href="recursion.html#recursion"><span class="std std-ref">recursively</span></a>, but the recursive call may only appear in the
expression, and not in the range. The recursive semantics for aggregates are the same as the
recursive semantics for the rest of QL. For example, we might define a predicate to calculate
the distance of a node in a graph from the leaves as follows:</p>
<div class="highlight-ql notranslate"><div class="highlight"><pre><span></span>int depth(Node n) {
  if not exists(n.getAChild())
  then result = 0
  else result = 1 + max(Node child | child = n.getAChild() | depth(child))
}
</pre></div>
</div>
<p>Here the recursive call is in the expression, which is legal. The recursive semantics for aggregates
are the same as the recursive semantics for the rest of QL. If you understand how aggregates work in
the non-recursive case then you should not find it difficult to use them recursively. However, it is
worth seeing how the evaluation of a recursive aggregation proceeds.</p>
<p>Consider the depth example we just saw with the following graph as input (arrows point from children to parents):</p>
<p><img alt="image0" src="../_images/monotonic-aggregates-graph.png" /></p>
<p>Then the evaluation of the <code class="docutils literal notranslate"><span class="pre">depth</span></code> predicate proceeds as follows:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Stage</strong></p></th>
<th class="head"><p><strong>depth</strong></p></th>
<th class="head"><p><strong>Comments</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td></td>
<td><p>We always begin with the empty set.</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">b),</span> <span class="pre">(0,</span> <span class="pre">d),</span> <span class="pre">(0,</span> <span class="pre">e)</span></code></p></td>
<td><p>The nodes with no children have depth 0. The recursive step for <strong>a</strong> and <strong>c</strong> fails to produce a value, since some of their children do not have values for <code class="docutils literal notranslate"><span class="pre">depth</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">b),</span> <span class="pre">(0,</span> <span class="pre">d),</span> <span class="pre">(0,</span> <span class="pre">e),</span> <span class="pre">(1,</span> <span class="pre">c)</span></code></p></td>
<td><p>The recursive step for <strong>c</strong> succeeds, since <code class="docutils literal notranslate"><span class="pre">depth</span></code> now has a value for all its children (<strong>d</strong> and <strong>e</strong>). The recursive step for <strong>a</strong> still fails.</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">b),</span> <span class="pre">(0,</span> <span class="pre">d),</span> <span class="pre">(0,</span> <span class="pre">e),</span> <span class="pre">(1,</span> <span class="pre">c),</span> <span class="pre">(2,</span> <span class="pre">a)</span></code></p></td>
<td><p>The recursive step for <strong>a</strong> succeeds, since <code class="docutils literal notranslate"><span class="pre">depth</span></code> now has a value for all its children (<strong>b</strong> and <strong>c</strong>).</p></td>
</tr>
</tbody>
</table>
<p>Here, we can see that at the intermediate stages it is very important for the aggregate to
fail if some of the children lack a value - this prevents erroneous values being added.</p>
</section>
</section>
</section>
<section id="any">
<span id="index-13"></span><h2>Any<a class="headerlink" href="#any" title="Link to this heading">¶</a></h2>
<p>The general syntax of an <code class="docutils literal notranslate"><span class="pre">any</span></code> expression is similar to the syntax of an
<a class="reference internal" href="#aggregations"><span class="std std-ref">aggregation</span></a>, namely:</p>
<div class="highlight-ql notranslate"><div class="highlight"><pre><span></span>any(&lt;variable declarations&gt; | &lt;formula&gt; | &lt;expression&gt;)
</pre></div>
</div>
<p>You should always include the <a class="reference internal" href="variables.html#variable-declarations"><span class="std std-ref">variable declarations</span></a>, but the
<a class="reference internal" href="formulas.html#formulas"><span class="std std-ref">formula</span></a> and <a class="reference internal" href="#expressions"><span class="std std-ref">expression</span></a> parts are optional.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">any</span></code> expression denotes any values that are of a particular form and that satisfy a
particular condition.
More precisely, the <code class="docutils literal notranslate"><span class="pre">any</span></code> expression:</p>
<ol class="arabic simple">
<li><p>Introduces temporary variables.</p></li>
<li><p>Restricts their values to those that satisfy the <code class="docutils literal notranslate"><span class="pre">&lt;formula&gt;</span></code> part (if it’s present).</p></li>
<li><p>Returns <code class="docutils literal notranslate"><span class="pre">&lt;expression&gt;</span></code> for each of those variables. If there is no <code class="docutils literal notranslate"><span class="pre">&lt;expression&gt;</span></code> part,
then it returns the variables themselves.</p></li>
</ol>
<p>The following table lists some examples of different forms of <code class="docutils literal notranslate"><span class="pre">any</span></code> expressions:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Expression</p></th>
<th class="head"><p>Values</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">any(File</span> <span class="pre">f)</span></code></p></td>
<td><p>all <code class="docutils literal notranslate"><span class="pre">File</span></code>s in the database</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">any(Element</span> <span class="pre">e</span> <span class="pre">|</span> <span class="pre">e.getName())</span></code></p></td>
<td><p>the names of all <code class="docutils literal notranslate"><span class="pre">Element</span></code>s in the database</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">any(int</span> <span class="pre">i</span> <span class="pre">|</span> <span class="pre">i</span> <span class="pre">=</span> <span class="pre">[0</span> <span class="pre">..</span> <span class="pre">3])</span></code></p></td>
<td><p>the integers <code class="docutils literal notranslate"><span class="pre">0</span></code>, <code class="docutils literal notranslate"><span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">2</span></code>, and <code class="docutils literal notranslate"><span class="pre">3</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">any(int</span> <span class="pre">i</span> <span class="pre">|</span> <span class="pre">i</span> <span class="pre">=</span> <span class="pre">[0</span> <span class="pre">..</span> <span class="pre">3]</span> <span class="pre">|</span> <span class="pre">i</span> <span class="pre">*</span> <span class="pre">i)</span></code></p></td>
<td><p>the integers <code class="docutils literal notranslate"><span class="pre">0</span></code>, <code class="docutils literal notranslate"><span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">4</span></code>, and <code class="docutils literal notranslate"><span class="pre">9</span></code></p></td>
</tr>
</tbody>
</table>
<blockquote class="pull-quote">
<div><p>Note</p>
<p>There is also a <a class="reference external" href="https://codeql.github.com/docs/ql-language-reference/ql-language-specification/#non-member-built-ins">built-in predicate</a>
<code class="docutils literal notranslate"><span class="pre">any()</span></code>. This is a predicate that always holds.</p>
</div></blockquote>
</section>
<section id="unary-operations">
<h2>Unary operations<a class="headerlink" href="#unary-operations" title="Link to this heading">¶</a></h2>
<p>A unary operation is a minus sign (<code class="docutils literal notranslate"><span class="pre">-</span></code>) or a plus sign (<code class="docutils literal notranslate"><span class="pre">+</span></code>) followed by an expression of type
<code class="docutils literal notranslate"><span class="pre">int</span></code> or <code class="docutils literal notranslate"><span class="pre">float</span></code>. For example:</p>
<div class="highlight-ql notranslate"><div class="highlight"><pre><span></span>-6.28
+(10 - 4)
+avg(float f | f = 3.4 or f = -9.8)
-sum(int i | i in [0 .. 9] | i * i)
</pre></div>
</div>
<p>A plus sign leaves the values of the expression unchanged, while a minus sign takes the
arithmetic negations of the values.</p>
</section>
<section id="binary-operations">
<span id="id5"></span><h2>Binary operations<a class="headerlink" href="#binary-operations" title="Link to this heading">¶</a></h2>
<p>A binary operation consists of an expression, followed by a binary operator, followed by
another expression. For example:</p>
<div class="highlight-ql notranslate"><div class="highlight"><pre><span></span>5 % 2
(9 + 1) / (-2)
&quot;Q&quot; + &quot;L&quot;
2 * min(float f | f in [-3 .. 3])
</pre></div>
</div>
<p id="index-14">You can use the following binary operators in QL:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Name</p></th>
<th class="head"><p>Symbol</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Addition/concatenation</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">+</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>Multiplication</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">*</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Division</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">/</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>Subtraction</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">-</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Modulo</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">%</span></code></p></td>
</tr>
</tbody>
</table>
<p>If both expressions are numbers, these operators act as standard arithmetic operators. For
example, <code class="docutils literal notranslate"><span class="pre">10.6</span> <span class="pre">-</span> <span class="pre">3.2</span></code> has value <code class="docutils literal notranslate"><span class="pre">7.4</span></code>, <code class="docutils literal notranslate"><span class="pre">123.456</span> <span class="pre">*</span> <span class="pre">0</span></code> has value <code class="docutils literal notranslate"><span class="pre">0</span></code>, and <code class="docutils literal notranslate"><span class="pre">9</span> <span class="pre">%</span> <span class="pre">4</span></code> has
value <code class="docutils literal notranslate"><span class="pre">1</span></code> (the remainder after dividing <code class="docutils literal notranslate"><span class="pre">9</span></code> by <code class="docutils literal notranslate"><span class="pre">4</span></code>).
If both operands are integers, then the result is an integer. Otherwise the result is a
floating-point number.</p>
<p>You can also use <code class="docutils literal notranslate"><span class="pre">+</span></code> as a string concatenation operator. In this case, at least one of the
expressions must be a string—the other expression is implicitly converted to a string using the
<code class="docutils literal notranslate"><span class="pre">toString()</span></code> predicate. The two expressions are concatenated, and the result is a string. For
example, the expression <code class="docutils literal notranslate"><span class="pre">221</span> <span class="pre">+</span> <span class="pre">&quot;B&quot;</span></code> has value <code class="docutils literal notranslate"><span class="pre">&quot;221B&quot;</span></code>.</p>
</section>
<section id="casts">
<span id="id6"></span><h2>Casts<a class="headerlink" href="#casts" title="Link to this heading">¶</a></h2>
<p>A cast allows you to constrain the <a class="reference internal" href="types.html#types"><span class="std std-ref">type</span></a> of an expression. This is similar to casting in other
languages, for example in Java.</p>
<dl class="simple">
<dt>You can write a cast in two ways:</dt><dd><ul class="simple">
<li><p>As a “postfix” cast: A dot followed by the name of a type in parentheses.
For example, <code class="docutils literal notranslate"><span class="pre">x.(Foo)</span></code> restricts the type of <code class="docutils literal notranslate"><span class="pre">x</span></code> to <code class="docutils literal notranslate"><span class="pre">Foo</span></code>.</p></li>
<li><p>As a “prefix” cast: A type in parentheses followed by another expression.
For example, <code class="docutils literal notranslate"><span class="pre">(Foo)x</span></code> also restricts the type of <code class="docutils literal notranslate"><span class="pre">x</span></code> to <code class="docutils literal notranslate"><span class="pre">Foo</span></code>.</p></li>
</ul>
</dd>
</dl>
<p>Note that a postfix cast is equivalent to a prefix cast surrounded by parentheses—<code class="docutils literal notranslate"><span class="pre">x.(Foo)</span></code>
is exactly equivalent to <code class="docutils literal notranslate"><span class="pre">((Foo)x)</span></code>.</p>
<p>Casts are useful if you want to call a <a class="reference internal" href="types.html#member-predicates"><span class="std std-ref">member predicate</span></a> that is only defined for a more
specific type. For example, the following query selects Java
<a class="reference external" href="https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Type.qll/type.Type$Class.html">classes</a>
that have a direct supertype called “List”:</p>
<div class="highlight-ql notranslate"><div class="highlight"><pre><span></span>import java

from Type t
where t.(Class).getASupertype().hasName(&quot;List&quot;)
select t
</pre></div>
</div>
<p>Since the predicate <code class="docutils literal notranslate"><span class="pre">getASupertype()</span></code> is defined for <code class="docutils literal notranslate"><span class="pre">Class</span></code>, but not for <code class="docutils literal notranslate"><span class="pre">Type</span></code>, you
can’t call <code class="docutils literal notranslate"><span class="pre">t.getASupertype()</span></code> directly. The cast <code class="docutils literal notranslate"><span class="pre">t.(Class)</span></code> ensures that <code class="docutils literal notranslate"><span class="pre">t</span></code> is
of type <code class="docutils literal notranslate"><span class="pre">Class</span></code>, so it has access to the desired predicate.</p>
<p>If you prefer to use a prefix cast, you can rewrite the <code class="docutils literal notranslate"><span class="pre">where</span></code> part as:</p>
<div class="highlight-ql notranslate"><div class="highlight"><pre><span></span>where ((Class)t).getASupertype().hasName(&quot;List&quot;)
</pre></div>
</div>
</section>
<section id="don-t-care-expressions">
<span id="index-15"></span><span id="id7"></span><h2>Don’t-care expressions<a class="headerlink" href="#don-t-care-expressions" title="Link to this heading">¶</a></h2>
<p>This is an expression written as a single underscore <code class="docutils literal notranslate"><span class="pre">_</span></code>. It represents any value. (You
“don’t care” what the value is.)</p>
<p>Unlike other expressions, a don’t-care expression does not have a type. In practice, this
means that <code class="docutils literal notranslate"><span class="pre">_</span></code> doesn’t have any <a class="reference internal" href="types.html#member-predicates"><span class="std std-ref">member predicates</span></a>, so you can’t
call <code class="docutils literal notranslate"><span class="pre">_.somePredicate()</span></code>.</p>
<p>For example, the following query selects all the characters in the string <code class="docutils literal notranslate"><span class="pre">&quot;hello&quot;</span></code>:</p>
<div class="highlight-ql notranslate"><div class="highlight"><pre><span></span>from string s
where s = &quot;hello&quot;.charAt(_)
select s
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">charAt(int</span> <span class="pre">i)</span></code> predicate is defined on strings and usually takes an <code class="docutils literal notranslate"><span class="pre">int</span></code> argument.
Here the don’t care expression <code class="docutils literal notranslate"><span class="pre">_</span></code> is used to tell the query to select characters at
every possible index. The query returns the values <code class="docutils literal notranslate"><span class="pre">h</span></code>, <code class="docutils literal notranslate"><span class="pre">e</span></code>, <code class="docutils literal notranslate"><span class="pre">l</span></code>, and <code class="docutils literal notranslate"><span class="pre">o</span></code>.</p>
</section>
</section>


    </article>

    <!-- GitHub footer, with links to terms and privacy statement -->
    <div class="px-3 px-md-6 f6 py-4 d-sm-flex flex-justify-between flex-row-reverse flex-items-center border-top">
        <ul class="list-style-none d-flex flex-items-center mb-3 mb-sm-0 lh-condensed-ultra">
            <li class="mr-3">
                <a href="https://twitter.com/github" title="GitHub on Twitter" style="color: #959da5;">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 273.5 222.3" class="d-block" height="18">
                        <path
                            d="M273.5 26.3a109.77 109.77 0 0 1-32.2 8.8 56.07 56.07 0 0 0 24.7-31 113.39 113.39 0 0 1-35.7 13.6 56.1 56.1 0 0 0-97 38.4 54 54 0 0 0 1.5 12.8A159.68 159.68 0 0 1 19.1 10.3a56.12 56.12 0 0 0 17.4 74.9 56.06 56.06 0 0 1-25.4-7v.7a56.11 56.11 0 0 0 45 55 55.65 55.65 0 0 1-14.8 2 62.39 62.39 0 0 1-10.6-1 56.24 56.24 0 0 0 52.4 39 112.87 112.87 0 0 1-69.7 24 119 119 0 0 1-13.4-.8 158.83 158.83 0 0 0 86 25.2c103.2 0 159.6-85.5 159.6-159.6 0-2.4-.1-4.9-.2-7.3a114.25 114.25 0 0 0 28.1-29.1"
                            fill="currentColor"></path>
                    </svg>
                </a>
            </li>
            <li class="mr-3">
                <a href="https://www.facebook.com/GitHub" title="GitHub on Facebook" style="color: #959da5;">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.3 15.4" class="d-block" height="18">
                        <path
                            d="M14.5 0H.8a.88.88 0 0 0-.8.9v13.6a.88.88 0 0 0 .8.9h7.3v-6h-2V7.1h2V5.4a2.87 2.87 0 0 1 2.5-3.1h.5a10.87 10.87 0 0 1 1.8.1v2.1h-1.3c-1 0-1.1.5-1.1 1.1v1.5h2.3l-.3 2.3h-2v5.9h3.9a.88.88 0 0 0 .9-.8V.8a.86.86 0 0 0-.8-.8z"
                            fill="currentColor"></path>
                    </svg>
                </a>
            </li>
            <li class="mr-3">
                <a href="https://www.youtube.com/github" title="GitHub on YouTube" style="color: #959da5;">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.17 13.6" class="d-block" height="16">
                        <path
                            d="M18.77 2.13A2.4 2.4 0 0 0 17.09.42C15.59 0 9.58 0 9.58 0a57.55 57.55 0 0 0-7.5.4A2.49 2.49 0 0 0 .39 2.13 26.27 26.27 0 0 0 0 6.8a26.15 26.15 0 0 0 .39 4.67 2.43 2.43 0 0 0 1.69 1.71c1.52.42 7.5.42 7.5.42a57.69 57.69 0 0 0 7.51-.4 2.4 2.4 0 0 0 1.68-1.71 25.63 25.63 0 0 0 .4-4.67 24 24 0 0 0-.4-4.69zM7.67 9.71V3.89l5 2.91z"
                            fill="currentColor"></path>
                    </svg>
                </a>
            </li>
            <li class="mr-3 flex-self-start">
                <a href="https://www.linkedin.com/company/github" title="GitHub on Linkedin" style="color: #959da5;">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19 18" class="d-block" height="18">
                        <path
                            d="M3.94 2A2 2 0 1 1 2 0a2 2 0 0 1 1.94 2zM4 5.48H0V18h4zm6.32 0H6.34V18h3.94v-6.57c0-3.66 4.77-4 4.77 0V18H19v-7.93c0-6.17-7.06-5.94-8.72-2.91z"
                            fill="currentColor"></path>
                    </svg>
                </a>
            </li>
            <li>
                <a href="https://github.com/github" title="GitHub's organization" style="color: #959da5;">
                    <svg version="1.1" width="20" height="20" viewBox="0 0 16 16" class="octicon octicon-mark-github"
                        aria-hidden="true">
                        <path fill-rule="evenodd"
                            d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z">
                        </path>
                    </svg>
                </a>
            </li>
        </ul>
        <ul class="list-style-none d-flex text-gray">
            <li class="mr-3">&copy; 
                <script type="text/javascript">document.write(new Date().getFullYear());</script> GitHub, Inc.</li>
            <li class="mr-3"><a
                    href="https://docs.github.com/github/site-policy/github-terms-of-service"
                    class="link-gray">Terms </a></li>
            <li><a href="https://docs.github.com/github/site-policy/github-privacy-statement"
                    class="link-gray">Privacy </a></li>
        </ul>
    </div>
</div>
</main>

<script type="text/javascript">
    $(document).ready(function () {
        $(".toggle > *").hide();
        $(".toggle .name").show();
        $(".toggle .name").click(function () {
            $(this).parent().children().not(".name").toggle(400);
            $(this).parent().children(".name").toggleClass("open");
        })
    });
</script>

  </body>
</html>